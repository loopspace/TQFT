% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
tqft --- a library for drawing TQFT diagrams with TikZ/PGF
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package defines some shapes useful for drawing TQFT diagrams with TikZ/PGF.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
tqft --- a library for drawing TQFT diagrams with TikZ/PGF
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2011 by Andrew Stacey <stacey@math.ntnu.no>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Andrew Stacey.

This work consists of the files  tqft.dtx,
                                 tqft_doc.tex,
and the derived files            tqft.ins,
                                 tqft.pdf,
                                 tqft_doc.pdf,
                                 tqft.sty, and
                                 tikzlibrarytqft.code.tex.

\endpostamble
\usedir{tex/latex/tqft}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
\usedir{tex/latex/tqft}
\generate{
  \file{tikzlibrary\jobname.code.tex}{\from{\jobname.dtx}{library}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/tqft}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/demopkg}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*package>
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{tqft}[2014/04/07 v2.0 Tikz/PGF commands for drawing TQFT diagrams]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{morefloats}
\usepackage{tikz}
\usepackage{\jobname}
\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{breakatwhitespace=true,breaklines=true,language=TeX}
 
\usepackage{fancyvrb}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{2418}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.0}{2011/05/03}{Converted to DTX file}
% \changes{2.0}{2014/04/07}{Converted nodes to pics}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{tqft.dtx}
% \title{The \textsf{tqft} package: codebase}
% \author{Andrew Stacey \\ \url{stacey@math.ntnu.no}}
%
% \maketitle
%
%
% \begin{tikzpicture}[every node/.style={tqft/cobordism style={draw,thick,red}}]
% \node[
%   tqft,
%   fill=orange,
%   fill opacity=.5,
%   boundary style={fill=purple},
%   cobordism style={draw,thick,red},
%   boundary lower style={draw,dashed,thick,blue},
%   boundary upper style={draw,green,thick},
%   incoming boundary components=4,
%   outgoing boundary components=6,
%   offset=-1.5,
% ] (a) {};
% \node[pin=north:1] at (a.incoming boundary 1) {};
% \node[pin=north:3] at (a.incoming boundary 3) {};
% \node[pin=south:1] at (a.outgoing boundary 1) {};
% \node[pin=south:4] at (a.outgoing boundary 4) {};
% \node[pin=south:6] at (a.outgoing boundary 6) {};
% \end{tikzpicture}
%
% \section{Introduction}
%
% This is a package for drawing TQFT diagrams using PGF/TikZ.
% Its inspiration was a question and answer on the website \url{http://tex.stackexchance.com}.
%
%
% \StopEventually{}
%
% \section{Implementation}
%
% \subsection{Old Version: Node Shapes}
%
% \iffalse
%<*package>
% \fi
%    \begin{macrocode}
\RequirePackage{pgfkeys}
\RequirePackage{pgf}
%    \end{macrocode}
%
% We can view the cobordisms from the \emph{input} or \emph{output} ends, the implementation of the choice is to draw an arc from 0 to 180 or from 0 to -180 so we just need to track minus signs.
% These macros are for that.
%    \begin{macrocode}
\def\pgf@tqft@minus{-}
\let\pgf@tqft@upper\@empty
\let\pgf@tqft@lower\pgf@tqft@minus
%    \end{macrocode}
% Some helpful extra functions.
%
% \Verb+\tqftset+ is our equivalent of \Verb+\tikzset+.
%    \begin{macrocode}
\def\tqftset#1{\pgfkeys{/pgf/tqft/.cd,#1}}
%    \end{macrocode}
% \begin{macro}{\tqft@process}
% This macro applies our flow transformation to the given coordinates, % with the result stored in \Verb+\pgf@x+ and \Verb+\pgf@y+.
%    \begin{macrocode}
\def\tqft@process#1#2{%
  \edef\tqft@px{#1}
  \edef\tqft@py{#2}
  \pgf@process{
    \pgftransformreset
    \let\tikz@transform=\pgfutil@empty
    \expandafter\tikzset\expandafter{\tqft@transformation}
    \tikz@transform
    \pgfpointtransformed{\pgfqpoint{\tqft@px}{\tqft@py}}
  }
}
%    \end{macrocode}
% \end{macro}
%
% Declare some dimension registers to hold the specifications of the cobordism.
%    \begin{macrocode}
\newdimen\tqft@xa
\newdimen\tqft@xb
\newdimen\tqft@c
\newdimen\tqft@ch
\newdimen\tqft@h
\newdimen\tqft@s
\newdimen\tqft@w
\newif\iftqft@within@node
%    \end{macrocode}
% Now we set up all the keys that we'll need in the course of this shape
%    \begin{macrocode}
\pgfkeys{
%    \end{macrocode}
% Add a key to switch between the two versions.
%    \begin{macrocode}
  /tikz/tqft/use nodes/.is choice,
  /tikz/tqft/use nodes/true/.code={%
    \tikzset{
%    \end{macrocode}
% If using nodes, set the defaults
%    \begin{macrocode}
      tqft/.style={%
        /tikz/shape=tqft cobordism,
        /pgf/tqft,
        /tikz/every tqft/.try
      },
%    \end{macrocode}
% Unknowns go to \Verb+/pgf/tqft+
%    \begin{macrocode}
      tqft/.unknown/.code={%
        \let\tqft@searchname=\pgfkeyscurrentname%
        \pgfkeys{%
          /pgf/tqft/\tqft@searchname={##1}
        }
      },
    }%
  },
%    \end{macrocode}
% If not using nodes, set the defaults for the library
%    \begin{macrocode}
  /tikz/tqft/use nodes/false/.code={%
    \tikzset{
      tqft/.style={%
        pic type=cobordism,
        tqft/.cd,
        every tqft/.try,
      },
%    \end{macrocode}
% Pass unknown keys on to TikZ.
%    \begin{macrocode}
      tqft/.unknown/.code={%
        \let\tqft@searchname=\pgfkeyscurrentname%
        \pgfkeys{%
          /tikz/\tqft@searchname={##1}
        }
      },
    }%
  },
  /tikz/tqft/use nodes=true,
%    \end{macrocode}
% This deals with unknown keys, passing them on to TikZ.
%    \begin{macrocode}
  /pgf/tqft/.unknown/.code={%
    \let\tqft@searchname=\pgfkeyscurrentname%
    \pgfkeysalso{%
      /tikz/\tqft@searchname={#1}
    }
  },
%    \end{macrocode}
% Let's play happy families!
%    \begin{macrocode}
  /pgf/tqft/.is family,
  /pgf/tqft,
%    \end{macrocode}
% This sets our shape to be the boundary circle
%    \begin{macrocode}
  boundary circle/.style={
    /tikz/shape=tqft boundary circle
  },
%    \end{macrocode}
% These set our number of boundary components
%    \begin{macrocode}
  incoming boundary components/.initial=5,
  outgoing boundary components/.initial=4,
%    \end{macrocode}
% This is the ``horizontal'' offset of the first outgoing component from the first incoming one.
%    \begin{macrocode}
  offset/.initial=0,
%    \end{macrocode}
% This is the ``vertical'' separation between boundary components.
%    \begin{macrocode}
  cobordism height/.initial=2cm,
%    \end{macrocode}
% This is the ``horizontal'' separation between boundary components.
%    \begin{macrocode}
  boundary separation/.initial=2cm,
%    \end{macrocode}
% These are the ``horizontal'' and ``vertical'' radii, respectively, of the boundary components (perhaps poorly named!).
%    \begin{macrocode}
  circle width/.initial=10pt,
  circle depth/.initial=5pt,
%    \end{macrocode}
% These control the separation between the node and its anchors.
%    \begin{macrocode}
  outer xsep/.initial=0pt,
  outer ysep/.initial=0pt,
  outer sep/.style={
    outer xsep=#1,
    outer ysep=#1
  },
%    \end{macrocode}
% This is our flow control.  The \Verb+flow+ key installs a transformation to be applied to our node shape.
% The possible transformations are stored in the following keys.
% They aren't just rotations so that the numbering is always ``top to bottom'' or ``left to right''.
%    \begin{macrocode}
  flow/.code={%
    \pgfkeys{/pgf/tqft/flow transformation/.expand twice/.expand once=\pgfkeysvalueof{/pgf/tqft/flow transformation #1}}
  },
  flow transformation south/.initial={},
  flow transformation north/.initial={%
    xscale=-1,rotate=180
  },
  flow transformation east/.initial={%
    rotate=90,xscale=-1
  },
  flow transformation west/.initial={%
    rotate=270
  },
  flow transformation/.initial={},
%    \end{macrocode}
% These control the direction from which we view the cobordism.
%    \begin{macrocode}
  view from/.is choice,
  view from/incoming/.code={%
    \let\pgf@tqft@upper\pgf@tqft@minus
    \let\pgf@tqft@lower\@empty
  },
  view from/outgoing/.code={%
  \let\pgf@tqft@lower\pgf@tqft@minus
    \let\pgf@tqft@upper\@empty
  },
%    \end{macrocode}
% The next set of keys are for styling the different pieces of a cobordism.
%    \begin{macrocode}
  boundary lower style contents/.initial={},
  boundary lower style/.code={%
    \pgfkeys{/pgf/tqft/boundary lower style contents/.style={%
        /tikz/.cd,#1
      }
    }
  },
  boundary style contents/.initial={},
  boundary style/.code={%
    \pgfkeys{/pgf/tqft/boundary style contents/.style={%
        /tikz/.cd,#1
      }
    }
  },
  boundary upper style contents/.initial={},
  boundary upper style/.code={%
    \pgfkeys{/pgf/tqft/boundary upper style contents/.style={%
        /tikz/.cd,#1
      }
    }
  },
  cobordism style contents/.initial={},
  cobordism style/.code={%
    \pgfkeys{/pgf/tqft/cobordism style contents/.style={%
        /tikz/.cd,#1%
      }
    }
  },
%    \end{macrocode}
% The next set of keys define some default shapes.
%    \begin{macrocode}
  pair of pants/.style={
    /tikz/tqft,
    incoming boundary components=1,
    outgoing boundary components=2,
    offset=-.5
  },
  /tikz/tqft pair of pants/.style={
    /pgf/tqft/pair of pants,
  },
  reverse pair of pants/.style={
    /tikz/tqft,
    incoming boundary components=2,
    outgoing boundary components=1,
    offset=.5
  },
  /tikz/tqft reverse pair of pants/.style={
    /pgf/tqft/reverse pair of pants,
  },
  cylinder to prior/.style={
    /tikz/tqft,
    incoming boundary components=1,
    outgoing boundary components=1,
    offset=-.5
  },
  /tikz/tqft cylinder to prior/.style={
    /pgf/tqft/cylinder to prior,
  },
  cylinder to next/.style={
    /tikz/tqft,
    incoming boundary components=1,
    outgoing boundary components=1,
    offset=.5
  },
  /tikz/tqft cylinder to next/.style={
    /pgf/tqft/cylinder to next,
  },
  cylinder/.style={
    /tikz/tqft,
    incoming boundary components=1,
    outgoing boundary components=1
  },
  /tikz/tqft cylinder/.style={
    /pgf/tqft/cylinder,
  },
  cup/.style={
    /tikz/tqft,
    incoming boundary components=1,
    outgoing boundary components=0
  },
  /tikz/tqft cup/.style={
    /pgf/tqft/cup,
  },
  cap/.style={
    /tikz/tqft,
    incoming boundary components=0,
    outgoing boundary components=1
  },
  /tikz/tqft cap/.style={
    /pgf/tqft/cap,
  },
}
%    \end{macrocode}
%
% \begin{macro}{tqft shape}
% This is a generic cobordism shape
%    \begin{macrocode}
\pgfdeclareshape{tqft cobordism}{
%    \end{macrocode}
% Save our specifications: incoming and outgoing boundary components
%    \begin{macrocode}
  \savedmacro{\tqft@incoming}{\edef\tqft@incoming{\pgfkeysvalueof{/pgf/tqft/incoming boundary components}}}
  \savedmacro{\tqft@outgoing}{\edef\tqft@outgoing{\pgfkeysvalueof{/pgf/tqft/outgoing boundary components}}}
%    \end{macrocode}
% and the offset (in units of boundary components) between the leading incoming and outgoing components (regarded as a shift of the outgoing components relative to the incoming)
%    \begin{macrocode}
  \savedmacro{\tqft@offset}{\edef\tqft@offset{\pgfkeysvalueof{/pgf/tqft/offset}}}
%    \end{macrocode}
% Now we save our dimensions: height, separation, the radii of the boundary circles, and outer seps, and the heights of the control points.
%    \begin{macrocode}
  \saveddimen{\tqft@height}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/cobordism height}}
  \saveddimen{\tqft@separation}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/boundary separation}}
  \saveddimen{\tqft@width}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/circle width}}
  \saveddimen{\tqft@depth}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/circle depth}}
  \saveddimen{\tqft@outerxsep}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/outer xsep}}
  \saveddimen{\tqft@outerysep}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/outer ysep}}
  \saveddimen{\tqft@control}{
  \pgfkeysgetvalue{/pgf/tqft/cobordism height}{\tqft@tempa}
  \pgfkeysgetvalue{/pgf/tqft/circle depth}{\tqft@tempb}
  \pgfmathsetlength{\pgf@x}{.5 * \tqft@tempa - 4 * \tqft@tempb}
}
%    \end{macrocode}
% This is the internal transformation that is in place
%    \begin{macrocode}
   \savedmacro{\tqft@transformation}{%
  \pgfkeysgetvalue{/pgf/tqft/flow transformation}{\tqft@transformation}
}
%    \end{macrocode}
% For the externally available anchors, we need to save a few things as well.
%
% Position of first incoming boundary in internal coordinates 
%    \begin{macrocode}
   \savedanchor{\tqft@start@incoming}{%
    \pgfmathsetlength{\pgf@x}{-(max(\pgfkeysvalueof{/pgf/tqft/incoming boundary components} - 1,\pgfkeysvalueof{/pgf/tqft/outgoing boundary components} - 1 + \pgfkeysvalueof{/pgf/tqft/offset}) + min(0,\pgfkeysvalueof{/pgf/tqft/offset}) )*\pgfkeysvalueof{/pgf/tqft/boundary separation}/2}
    \pgfmathsetlength{\pgf@y}{.5 * \pgfkeysvalueof{/pgf/tqft/cobordism height}}
}
%    \end{macrocode}
% Position of first outgoing boundary in internal coordinates 
%    \begin{macrocode}
   \savedanchor{\tqft@start@outgoing}{%
    \pgfmathsetlength{\pgf@x}{-(max(\pgfkeysvalueof{/pgf/tqft/incoming boundary components} - 1,\pgfkeysvalueof{/pgf/tqft/outgoing boundary components} - 1 + \pgfkeysvalueof{/pgf/tqft/offset}) + min(0,\pgfkeysvalueof{/pgf/tqft/offset})- 2*\pgfkeysvalueof{/pgf/tqft/offset})*\pgfkeysvalueof{/pgf/tqft/boundary separation}/2}
    \pgfmathsetlength{\pgf@y}{-.5 * \pgfkeysvalueof{/pgf/tqft/cobordism height}}
}
%    \end{macrocode}
% For completeness, we record the size of the text box (not that we expect any text, but you never know)
%    \begin{macrocode}
\savedanchor{\tqft@textsize}{%
  \pgf@y=-.5\ht\pgfnodeparttextbox%
  \pgf@x=-.5\wd\pgfnodeparttextbox%
}
%    \end{macrocode}
%
% These are our externally available anchors
%    \begin{macrocode}
  \anchor{centre}{\pgfpointorigin}
  \anchor{center}{\pgfpointorigin}
\anchor{text}{
  \tqft@textsize
}
\anchor{north}{%
  \pgf@ya=\tqft@height\relax
  \pgf@yb=.5\pgf@ya
  \advance\pgf@yb by \tqft@outerysep\relax
  \tqft@process{0pt}{\the\pgf@yb}
}
\anchor{south}{%
  \pgf@yb=\tqft@height\relax
  \pgf@ya=.5\pgf@yb
  \advance\pgf@ya by \tqft@outerysep\relax
  \pgf@yb=-\pgf@ya
  \tqft@process{0pt}{\the\pgf@yb}
}
\anchor{west}{%
  \tqft@start@incoming
  \pgf@xa=\pgf@x
  \advance\pgf@xa by -\tqft@width
  \pgf@ya=\pgf@y
  \tqft@start@outgoing
  \pgf@xb=\pgf@x
  \advance\pgf@xb by -\tqft@width
  \pgf@yb=\pgf@y
  \pgf@xc=.5\pgf@xa
  \advance\pgf@xc by .5\pgf@xb
  \pgf@yc=.5\pgf@ya
  \advance\pgf@yc by .5\pgf@yb
  \advance\pgf@xc by -\tqft@outerxsep\relax
  \tqft@process{\the\pgf@xc}{\the\pgf@yc}
}
\anchor{east}{%
  \tqft@start@incoming
  \pgf@xa=\pgf@x
  \pgfmathsetlength{\pgf@xa}{\pgf@xa + (\tqft@incoming - 1) * \tqft@separation}
  \advance\pgf@xa by \tqft@width\relax
  \pgf@ya=\pgf@y
  \tqft@start@outgoing
  \pgf@xb=\pgf@x
  \pgfmathsetlength{\pgf@xb}{\pgf@xb + (\tqft@outgoing - 1) * \tqft@separation}
  \advance\pgf@xb by \tqft@width\relax
  \pgf@yb=\pgf@y
  \pgf@xc=.5\pgf@xa
  \advance\pgf@xc by .5\pgf@xb
  \pgf@yc=.5\pgf@ya
  \advance\pgf@yc by .5\pgf@yb
  \advance\pgf@xc by \tqft@outerxsep\relax
  \tqft@process{\the\pgf@xc}{\the\pgf@yc}
}
\anchor{north west}{
  \tqft@start@incoming
  \pgf@xc=\pgf@x
  \pgf@yc=\pgf@y
  \advance\pgf@xc by -\tqft@width\relax
  \advance\pgf@yc by \tqft@outerysep\relax
  \advance\pgf@xc by -\tqft@outerxsep\relax
  \tqft@process{\the\pgf@xc}{\the\pgf@yc}
}
\anchor{south west}{
  \tqft@start@outgoing
  \pgf@xc=\pgf@x
  \pgf@yc=\pgf@y
  \advance\pgf@xc by -\tqft@width\relax
  \advance\pgf@yc by -\tqft@outerysep\relax
  \advance\pgf@xc by -\tqft@outerxsep\relax
  \tqft@process{\the\pgf@xc}{\the\pgf@yc}
}
\anchor{north east}{
  \tqft@start@incoming
  \pgf@xc=\pgf@x
  \pgfmathsetlength{\pgf@xc}{\pgf@xc + (\tqft@incoming - 1)*\tqft@separation}
  \pgf@yc=\pgf@y
  \advance\pgf@xc by \tqft@width\relax
  \advance\pgf@yc by \tqft@outerysep\relax
  \advance\pgf@xc by \tqft@outerxsep\relax
  \tqft@process{\the\pgf@xc}{\the\pgf@yc}
}
\anchor{south east}{
  \tqft@start@outgoing
  \pgf@xc=\pgf@x
  \pgfmathsetlength{\pgf@xc}{\pgf@xc + (\tqft@outgoing - 1)*\tqft@separation}
  \pgf@yc=\pgf@y
  \advance\pgf@xc by \tqft@width\relax
  \advance\pgf@yc by -\tqft@outerysep\relax
  \advance\pgf@xc by \tqft@outerxsep\relax
  \tqft@process{\the\pgf@xc}{\the\pgf@yc}
}
%    \end{macrocode}
% To define anchors at the boundary components requires a bit of trickery borrowed from the ``regular polygon'' shape.
%    \begin{macrocode}
\expandafter\pgfutil@g@addto@macro\csname pgf@sh@s@tqft cobordism\endcsname{%
  \c@pgf@counta\tqft@incoming\relax%
  \pgfmathloop%
  \ifnum\c@pgf@counta>0\relax%
  \pgfutil@ifundefined{pgf@anchor@tqft cobordism@incoming boundary\space\the\c@pgf@counta}{%
    \expandafter\xdef\csname pgf@anchor@tqft cobordism@incoming boundary\space\the\c@pgf@counta\endcsname{%
  \noexpand\tqft@start@incoming
  \noexpand\pgfmathsetlength{\noexpand\pgf@y}{\noexpand\pgf@y + \noexpand\tqft@outerysep}
  \noexpand\pgfmathsetlength{\noexpand\pgf@x}{\noexpand\pgf@x + (\the\c@pgf@counta - 1) * \noexpand\tqft@separation}
  \noexpand\tqft@process{\noexpand\the\noexpand\pgf@x}{\noexpand\the\noexpand\pgf@y}
  }
  }{\c@pgf@counta0\relax}%
  \advance\c@pgf@counta-1\relax%
  \repeatpgfmathloop%
}
\expandafter\pgfutil@g@addto@macro\csname pgf@sh@s@tqft cobordism\endcsname{%
  \c@pgf@counta\tqft@outgoing\relax%
  \pgfmathloop%
  \ifnum\c@pgf@counta>0\relax%
  \pgfutil@ifundefined{pgf@anchor@tqft cobordism@outgoing boundary\space\the\c@pgf@counta}{%
    \expandafter\xdef\csname pgf@anchor@tqft cobordism@outgoing boundary\space\the\c@pgf@counta\endcsname{%
  \noexpand\tqft@start@outgoing
  \noexpand\pgfmathsetlength{\noexpand\pgf@y}{\noexpand\pgf@y - \noexpand\tqft@outerysep}
  \noexpand\pgfmathsetlength{\noexpand\pgf@x}{\noexpand\pgf@x + (\the\c@pgf@counta - 1) * \noexpand\tqft@separation}
  \noexpand\tqft@process{\noexpand\the\noexpand\pgf@x}{\noexpand\the\noexpand\pgf@y}
  }
  }{\c@pgf@counta0\relax}%
  \advance\c@pgf@counta-1\relax%
  \repeatpgfmathloop%
}
\expandafter\pgfutil@g@addto@macro\csname pgf@sh@s@tqft cobordism\endcsname{%
  \c@pgf@counta\tqft@incoming\relax%
  \advance\c@pgf@counta-1\relax
  \pgfmathloop%
  \ifnum\c@pgf@counta>0\relax%
  \pgfutil@ifundefined{pgf@anchor@tqft cobordism@after incoming boundary\space\the\c@pgf@counta}{%
    \expandafter\xdef\csname pgf@anchor@tqft cobordism@after incoming boundary\space\the\c@pgf@counta\endcsname{%
  \noexpand\tqft@start@incoming
  \noexpand\pgfmathsetlength{\noexpand\pgf@y}{.25 * \noexpand\pgf@y +.75 * \noexpand\tqft@control + \noexpand\tqft@outerysep}
  \noexpand\pgfmathsetlength{\noexpand\pgf@x}{\noexpand\pgf@x + (\the\c@pgf@counta - .5) * \noexpand\tqft@separation}
  \noexpand\tqft@process{\noexpand\the\noexpand\pgf@x}{\noexpand\the\noexpand\pgf@y}
  }
  }{\c@pgf@counta0\relax}%
  \advance\c@pgf@counta-1\relax%
  \repeatpgfmathloop%
}
\expandafter\pgfutil@g@addto@macro\csname pgf@sh@s@tqft cobordism\endcsname{%
  \c@pgf@counta\tqft@outgoing\relax%
  \advance\c@pgf@counta-1\relax
  \pgfmathloop%
  \ifnum\c@pgf@counta>0\relax%
  \pgfutil@ifundefined{pgf@anchor@tqft cobordism@after outgoing boundary\space\the\c@pgf@counta}{%
    \expandafter\xdef\csname pgf@anchor@tqft cobordism@after outgoing boundary\space\the\c@pgf@counta\endcsname{%
  \noexpand\tqft@start@outgoing
  \noexpand\pgfmathsetlength{\noexpand\pgf@y}{.25 * \noexpand\pgf@y -.75 * \noexpand\tqft@control - \noexpand\tqft@outerysep}
  \noexpand\pgfmathsetlength{\noexpand\pgf@x}{\noexpand\pgf@x + (\the\c@pgf@counta - .5) * \noexpand\tqft@separation}
  \noexpand\tqft@process{\noexpand\the\noexpand\pgf@x}{\noexpand\the\noexpand\pgf@y}
  }
  }{\c@pgf@counta0\relax}%
  \advance\c@pgf@counta-1\relax%
  \repeatpgfmathloop%
}
%    \end{macrocode}
% Now we define the background path.
% This is the upper part of the cobordism.
%    \begin{macrocode}
  \backgroundpath{
%    \end{macrocode}
% Apply the internal transformation
%    \begin{macrocode}
    \let\tikz@transform=\pgfutil@empty
    \expandafter\tikzset\expandafter{\tqft@transformation}
    \tikz@transform
%    \end{macrocode}
% Convert the boundary separation and width to lengths
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@s}{\tqft@separation}
    \pgfmathsetlength{\tqft@w}{2*\tqft@width}
%    \end{macrocode}
% Compute the starting position of the incoming boundary components so that we get the centre anchor on the centre of the cobordism
%    \begin{macrocode}
\tqft@start@incoming
\tqft@xa=\pgf@x
    \advance\tqft@xa by -.5\tqft@w\relax
\tqft@h=\pgf@y
    \tqft@xb=\tqft@xa
    \advance\tqft@xb by \tqft@w\relax
\tqft@c=\tqft@control\relax
%    \end{macrocode}
% Do we have any incoming boundary components at all?
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
%    \end{macrocode}
% Yes, so move to the position of the first and draw it
%    \begin{macrocode}
    \pgfpathmoveto{\pgfqpoint{\tqft@xa}{\tqft@h}}
     \pgfpatharc{\pgf@tqft@upper180}{0}{\tqft@width and \tqft@depth}
%    \end{macrocode}
% Do we have any more incoming boundary components?
%    \begin{macrocode}
   \ifnum\tqft@incoming>1
%    \end{macrocode}
% Yes, so iterate over the remaining incoming boundary components
%    \begin{macrocode}
    \foreach \tqft@k in {2,...,\tqft@incoming} {
     \advance\tqft@xa by \tqft@k\tqft@s
     \advance\tqft@xb by \tqft@k\tqft@s
     \advance\tqft@xb by -2\tqft@s
     \advance\tqft@xa by -\tqft@s
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@c}}{\pgfqpoint{\tqft@xa}{\tqft@c}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
     \pgfpatharc{\pgf@tqft@upper180}{0}{\tqft@width and \tqft@depth}
    }
    \fi
%    \end{macrocode}
% If we don't have any outgoing boundary components, may as well close up now.
%    \begin{macrocode}
    \ifnum\tqft@outgoing=0
     \advance\tqft@xb by \tqft@incoming\tqft@s
     \advance\tqft@xb by -\tqft@s
     \pgfmathsetlength{\tqft@ch}{min(0,max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1)))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
    \fi
    \fi
%    \end{macrocode}
% Shift down to the outgoing components, if we have any
%    \begin{macrocode}
    \ifnum\tqft@outgoing>0
     \advance\tqft@xb by \tqft@incoming\tqft@s
     \advance\tqft@xb by -\tqft@s
     \pgfmathsetlength{\tqft@xa}{\tqft@xa + (\tqft@outgoing - 1 + \tqft@offset) * \tqft@separation + 2*\tqft@width}
%    \end{macrocode}
% If we had incoming boundaries, this is a curveto, otherwise it's a moveto
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
     \pgfmathsetlength{\tqft@ch}{min(0,max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1)))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \else
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \fi
     \tqft@xb=\tqft@xa
     \advance\tqft@xb by -\tqft@w
%    \end{macrocode}
% Now draw the lower components
%    \begin{macrocode}
     \pgfpatharc{0}{\pgf@tqft@upper180}{\tqft@width and \tqft@depth}
%    \end{macrocode}
% Now iterate over the remaining outgoing boundary components
%    \begin{macrocode}
    \ifnum\tqft@outgoing>1
    \foreach \tqft@k in {2,...,\tqft@outgoing} {
     \advance\tqft@xa by -\tqft@k\tqft@s
     \advance\tqft@xb by -\tqft@k\tqft@s
     \advance\tqft@xb by 2\tqft@s
     \advance\tqft@xa by \tqft@s
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@c}}{\pgfqpoint{\tqft@xa}{-\tqft@c}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
     \pgfpatharc{0}{\pgf@tqft@upper180}{\tqft@width and \tqft@depth}
    }
    \fi
%    \end{macrocode}
% Shift back up to the incoming components, if we had any, otherwise arc back to our starting point
%    \begin{macrocode}
     \advance\tqft@xb by -\tqft@outgoing\tqft@s
     \advance\tqft@xb by \tqft@s
    \ifnum\tqft@incoming>0
     \pgfmathsetlength{\tqft@xa}{\tqft@xa - (\tqft@outgoing -1 + \tqft@offset) * \tqft@separation - 2*\tqft@width}
     \pgfmathsetlength{\tqft@ch}{min(0,max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1)))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
    \else
     \pgfmathsetlength{\tqft@ch}{min(0,max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1)))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \fi
    \fi
%    \end{macrocode}
% Close the path
%    \begin{macrocode}
     \pgfpathclose
  }
%    \end{macrocode}
% End of background path
% Now we define the behind background path.
% This is the lower part of the boundary circles.
%    \begin{macrocode}
  \behindbackgroundpath{
%    \end{macrocode}
% Apply the internal transformation
%    \begin{macrocode}
    \let\tikz@transform=\pgfutil@empty
    \expandafter\tikzset\expandafter{\tqft@transformation}
    \tikz@transform
%    \end{macrocode}
% Convert the boundary separation and width to lengths
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@s}{\tqft@separation}
    \pgfmathsetlength{\tqft@w}{2*\tqft@width}
%    \end{macrocode}
% Compute the starting position of the incoming boundary components so that we get the centre anchor on the centre of the cobordism
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@xa}{-(max(\tqft@incoming - 1,\tqft@outgoing - 1 + \tqft@offset) + min(0,\tqft@offset) + 2)*\tqft@separation/2}
    \pgfmathsetlength{\tqft@h}{.5 * \tqft@height}
%    \end{macrocode}
% This section draws the boundary circles
%    \begin{macrocode}
    {
%    \end{macrocode}
% Initialise the TikZ path settings and read in the style options for the boundary
%    \begin{macrocode}
      \tikz@mode@fillfalse%
      \tikz@mode@drawfalse%
      \let\tikz@mode=\pgfutil@empty
      \let\tikz@options=\pgfutil@empty
      \tqftset{boundary style contents}
      \tikz@mode
      \tikz@options
%    \end{macrocode}
% Do we have any incoming boundary components at all?
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
%    \end{macrocode}
% Yes, so iterate over them
%    \begin{macrocode}
    \foreach \tqft@k in {1,...,\tqft@incoming} {
     \advance\tqft@xa by \tqft@k\tqft@s
     \pgfpathellipse{\pgfqpoint{\tqft@xa}{\tqft@h}}{\pgfqpoint{\tqft@width}{0pt}}{\pgfqpoint{0pt}{\tqft@depth}}
    }
    \fi
%    \end{macrocode}
% Now iterate over the outgoing boundary components, if we have any
%    \begin{macrocode}
    \ifnum\tqft@outgoing>0
     \pgfmathsetlength{\tqft@xa}{\tqft@xa + (\tqft@outgoing + \tqft@offset + 1) * \tqft@separation}
    \foreach \tqft@k in {1,...,\tqft@outgoing} {
     \advance\tqft@xa by -\tqft@k\tqft@s
%     \advance\tqft@xa by \tqft@s
     \pgfpathellipse{\pgfqpoint{\tqft@xa}{-\tqft@h}}{\pgfqpoint{\tqft@width}{0pt}}{\pgfqpoint{0pt}{\tqft@depth}}
    }
    \fi
%    \end{macrocode}
%    \begin{macrocode}
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@fill fill,\fi%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
    }
%    \end{macrocode}
% This section draws the lower parts of the boundary circles
%    \begin{macrocode}
    {
%    \end{macrocode}
% Initialise the TikZ path settings and read in the style options for the boundary
%    \begin{macrocode}
      \tikz@mode@fillfalse%
      \tikz@mode@drawfalse%
      \let\tikz@mode=\pgfutil@empty
      \let\tikz@options=\pgfutil@empty
      \tqftset{boundary lower style contents}
      \tikz@mode
      \tikz@options
      \advance\tqft@xa by .5\tqft@w
%    \end{macrocode}
% Do we have any incoming boundary components at all?
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
%    \end{macrocode}
% Yes, so iterate over them
%    \begin{macrocode}
    \foreach \tqft@k in {1,...,\tqft@incoming} {
     \advance\tqft@xa by \tqft@k\tqft@s
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{\tqft@h}}
     \pgfpatharc{0}{\pgf@tqft@lower180}{\tqft@width and \tqft@depth}
    }
    \fi
%    \end{macrocode}
% Now iterate over the outgoing boundary components, if we have any
%    \begin{macrocode}
    \ifnum\tqft@outgoing>0
     \pgfmathsetlength{\tqft@xa}{\tqft@xa + (\tqft@outgoing + \tqft@offset + 1) * \tqft@separation}
    \foreach \tqft@k in {1,...,\tqft@outgoing} {
     \advance\tqft@xa by -\tqft@k\tqft@s
%     \advance\tqft@xa by \tqft@s
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{-\tqft@h}}
     \pgfpatharc{0}{\pgf@tqft@lower180}{\tqft@width and \tqft@depth}
    }
    \fi
%    \end{macrocode}
%    \begin{macrocode}
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@fill fill,\fi%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
    }
  }
%    \end{macrocode}
% End of behind background path.
%
% Now we define the before background path.
% This is the upper part of the boundary circles and the cobordism edge.
%    \begin{macrocode}
  \beforebackgroundpath{
%    \end{macrocode}
% We \emph{don't} apply the internal transformation as it is already in place from the \Verb+\backgroundpath+.
% Convert the boundary separation and width to lengths
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@s}{\tqft@separation}
    \pgfmathsetlength{\tqft@w}{2*\tqft@width}
%    \end{macrocode}
% Compute the starting position of the incoming boundary components so that we get the centre anchor on the centre of the cobordism
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@xa}{-(max(\tqft@incoming - 1,\tqft@outgoing - 1 + \tqft@offset) + min(0,\tqft@offset))*\tqft@s/2 - \tqft@width}
    \tqft@xb=\tqft@xa
    \advance\tqft@xb by \tqft@w
\tqft@c=\tqft@control\relax
    \pgfmathsetlength{\tqft@h}{.5 * \tqft@height}
%    \end{macrocode}
% This section draws the non-boundary part of the cobordism.
%    \begin{macrocode}
   {
%    \end{macrocode}
% Initialise the TikZ path settings and read in the style options for the boundary
%    \begin{macrocode}
      \tikz@mode@fillfalse%
      \tikz@mode@drawfalse%
      \let\tikz@mode=\pgfutil@empty
      \let\tikz@options=\pgfutil@empty
      \tqftset{cobordism style contents}
      \tikz@mode
      \tikz@options
% Do we have any incoming boundary components at all?
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
%    \end{macrocode}
% Do we have more than one?
%    \begin{macrocode}
   \ifnum\tqft@incoming>1
%    \end{macrocode}
% Yes, so iterate over the remaining incoming boundary components
%    \begin{macrocode}
    \foreach \tqft@k in {2,...,\tqft@incoming} {
     \advance\tqft@xa by \tqft@k\tqft@s
     \advance\tqft@xb by \tqft@k\tqft@s
     \advance\tqft@xb by -2\tqft@s
     \advance\tqft@xa by -\tqft@s
    \pgfpathmoveto{\pgfqpoint{\tqft@xb}{\tqft@h}}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@c}}{\pgfqpoint{\tqft@xa}{\tqft@c}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
    }
    \fi
%    \end{macrocode}
% If we don't have any outgoing boundary components, may as well close up now.
%    \begin{macrocode}
    \ifnum\tqft@outgoing=0
     \advance\tqft@xb by \tqft@incoming\tqft@s
     \advance\tqft@xb by -\tqft@s
     \pgfmathsetlength{\tqft@ch}{min(0,max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1)))}
    \pgfpathmoveto{\pgfqpoint{\tqft@xb}{\tqft@h}}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
    \fi
    \fi
%    \end{macrocode}
% Shift down to the outgoing components, if we have any
%    \begin{macrocode}
    \ifnum\tqft@outgoing>0
     \advance\tqft@xb by \tqft@incoming\tqft@s
     \advance\tqft@xb by -\tqft@s
     \pgfmathsetlength{\tqft@xa}{\tqft@xa + (\tqft@outgoing - 1 + \tqft@offset) * \tqft@separation + 2*\tqft@width}
%    \end{macrocode}
% If we had incoming boundaries, this is a curveto, otherwise it's a moveto
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
     \pgfmathsetlength{\tqft@ch}{min(0,max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1)))}
     \pgfpathmoveto{\pgfqpoint{\tqft@xb}{\tqft@h}}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \else
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \fi
     \tqft@xb=\tqft@xa
     \advance\tqft@xb by -\tqft@w
%    \end{macrocode}
% Now draw the lower components
%    \begin{macrocode}
     \pgfpathmoveto{\pgfqpoint{\tqft@xb}{-\tqft@h}}
%    \end{macrocode}
% Now iterate over the remaining outgoing boundary components
%    \begin{macrocode}
    \ifnum\tqft@outgoing>1
    \foreach \tqft@k in {2,...,\tqft@outgoing} {
     \advance\tqft@xa by -\tqft@k\tqft@s
     \advance\tqft@xb by -\tqft@k\tqft@s
     \advance\tqft@xb by 2\tqft@s
     \advance\tqft@xa by \tqft@s
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@c}}{\pgfqpoint{\tqft@xa}{-\tqft@c}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
     \advance\tqft@xa by -\tqft@w
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    }
    \fi
%    \end{macrocode}
% Shift back up to the incoming components, if we had any, otherwise arc back to our starting point
%    \begin{macrocode}
     \advance\tqft@xb by -\tqft@outgoing\tqft@s
     \advance\tqft@xb by \tqft@s
    \ifnum\tqft@incoming>0
     \pgfmathsetlength{\tqft@xa}{\tqft@xa - (\tqft@outgoing -1 + \tqft@offset) * \tqft@separation - 2*\tqft@width}
     \pgfmathsetlength{\tqft@ch}{min(0,max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1)))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
    \else
     \pgfmathsetlength{\tqft@ch}{min(0,max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1)))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \fi
    \fi
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@fill fill,\fi%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
}
%    \end{macrocode}
% This section draws the upper parts of the boundary circles
%    \begin{macrocode}
    {
%    \end{macrocode}
% Initialise the TikZ path settings and read in the style options for the boundary
%    \begin{macrocode}
\let\tqft@bdry@path=\pgfutil@empty
\let\tqft@bdry@node@path=\pgfutil@empty
\pgfsyssoftpath@setcurrentpath{\tqft@bdry@path}
      \tikz@mode@fillfalse%
      \tikz@mode@drawfalse%
      \let\tikz@mode=\pgfutil@empty
      \let\tikz@options=\pgfutil@empty
      \tqftset{boundary upper style contents}
      \tikz@mode
      \tikz@options
      \advance\tqft@xa by -\tqft@s
      \advance\tqft@xa by \tqft@w
%    \end{macrocode}
% Do we have any incoming boundary components at all?
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
%    \end{macrocode}
% Yes, so iterate over them
%    \begin{macrocode}
    \foreach \tqft@k in {1,...,\tqft@incoming} {
     \advance\tqft@xa by \tqft@k\tqft@s
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{\tqft@h}}
     \pgfpatharc{0}{\pgf@tqft@upper180}{\tqft@width and \tqft@depth}
  \ifx\tikz@fig@name\pgfutil@empty
  \else
  {
    \advance\tqft@xa by -\tqft@width
    \pgftransformshift{\pgfqpoint{\tqft@xa}{\tqft@h}}
    \tqft@within@nodetrue
    \pgfsyssoftpath@getcurrentpath{\tqft@bdry@path}
    \pgfsyssoftpath@setcurrentpath{\tqft@bdry@node@path}
    \pgfnode{tqft boundary circle}{centre}{}{\tikz@fig@name\space incoming \tqft@k}{}
    \pgfsyssoftpath@getcurrentpath{\tqft@bdry@node@path}
    \pgfsyssoftpath@setcurrentpath{\tqft@bdry@path}
  }
  \fi
    }
    \fi
%    \end{macrocode}
% Now iterate over the outgoing boundary components, if we have any
%    \begin{macrocode}
    \ifnum\tqft@outgoing>0
     \pgfmathsetlength{\tqft@xa}{\tqft@xa + (\tqft@outgoing + \tqft@offset + 1) * \tqft@separation}
    \foreach \tqft@k in {1,...,\tqft@outgoing} {
     \advance\tqft@xa by -\tqft@k\tqft@s
%     \advance\tqft@xa by \tqft@s
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{-\tqft@h}}
     \pgfpatharc{0}{\pgf@tqft@upper180}{\tqft@width and \tqft@depth}
  \ifx\tikz@fig@name\pgfutil@empty
  \else
  {
    \pgfmathtruncatemacro{\tqft@l}{\tqft@outgoing + 1 - \tqft@k}
    \advance\tqft@xa by -\tqft@width
    \pgftransformshift{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \tqft@within@nodetrue
    \pgfsyssoftpath@getcurrentpath{\tqft@bdry@path}
    \pgfsyssoftpath@setcurrentpath{\tqft@bdry@node@path}
    \pgfnode{tqft boundary circle}{centre}{}{\tikz@fig@name\space outgoing \tqft@l}{}
    \pgfsyssoftpath@getcurrentpath{\tqft@bdry@node@path}
    \pgfsyssoftpath@setcurrentpath{\tqft@bdry@path}
  }
  \fi
    }
    \fi
%    \end{macrocode}
%    \begin{macrocode}
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@fill fill,\fi%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{boundary circle shape}
% This is a the shape of the boundary circles
%    \begin{macrocode}
\pgfdeclareshape{tqft boundary circle}{
%    \end{macrocode}
% Now we save our dimensions: height, separation, and the radii of the boundary circles
%    \begin{macrocode}
  \saveddimen{\tqft@height}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/cobordism height}}
  \saveddimen{\tqft@separation}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/boundary separation}}
  \saveddimen{\tqft@width}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/circle width}}
  \saveddimen{\tqft@depth}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/circle depth}}
%    \end{macrocode}
%
% For the externally available anchors, we need to save the declared transformation; we save the actual transformation, not the macro that points to it.
% If we're called within the main cobordism shape, the transformation is already applied so we ignore it.
%    \begin{macrocode}
   \savedmacro{\tqft@transformation}{%
  \iftqft@within@node
  \let\tqft@transformation=\pgfutil@empty
  \else
  \pgfkeysgetvalue{/pgf/tqft/flow transformation}{\tqft@transformation}
  \fi
}
%    \end{macrocode}
%    \begin{macrocode}
   \savedanchor{\tqft@centre}{%
  \pgfpointorigin}
%    \end{macrocode}
% For completeness, we record the size of the text box (not that we expect any text, but you never know)
%    \begin{macrocode}
\savedanchor{\tqft@textsize}{%
  \pgf@y=-.5\ht\pgfnodeparttextbox%
  \pgf@x=-.5\wd\pgfnodeparttextbox%
}
%    \end{macrocode}
% These are our externally available anchors
%    \begin{macrocode}
  \anchor{centre}{\tqft@centre}
  \anchor{center}{\tqft@centre}
\anchor{text}{
  \tqft@textsize
}
  \anchor{next}{%
  \tqft@process{\tqft@separation}{0pt}}%
%    \end{macrocode}
%    \begin{macrocode}
  \anchor{prior}{%
  \tqft@process{-\tqft@separation}{0pt}}%
%    \end{macrocode}
%    \begin{macrocode}
  \anchor{above}{%
  \tqft@process{0pt}{\tqft@height}}%
%    \end{macrocode}
%    \begin{macrocode}
  \anchor{below}{%
  \tqft@process{0pt}{-\tqft@height}}%
%    \end{macrocode}
% The anchor border is the ellipse, but we need to take into account the possible transformation.
% (This isn't right if the origin is shifted.)
% At the moment, '0 degrees' is interpreted in the transformed coordinate system.
% Should provide a system whereby that can be intepreted in the main coordinate system.
%    \begin{macrocode}
  \anchorborder{
%    \end{macrocode}
% This next \Verb+\pgf@process+ makes the angles absolute.
% Comment it out to make the angles relative.
%    \begin{macrocode}
  \tqft@process{\the\pgf@x}{\the\pgf@y}
  \edef\tqft@marshal{%
    \noexpand\pgfpointborderellipse
    {\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}
    {\noexpand\pgfqpoint{\tqft@width}{\tqft@depth}}
  }%
  \tqft@marshal
  \tqft@process{\the\pgf@x}{\the\pgf@y}
}
%    \end{macrocode}
% Now we define the background path.
% This is the upper part of the cobordism.
%    \begin{macrocode}
  \backgroundpath{
%    \end{macrocode}
% Apply the internal transformation if we're not within a node
%    \begin{macrocode}
    \let\tikz@transform=\pgfutil@empty
    \expandafter\tikzset\expandafter{\tqft@transformation}
    \tikz@transform
%    \end{macrocode}
% Draw the boundary circle
%    \begin{macrocode}
  \pgfpathellipse{\pgfqpoint{0pt}{0pt}}{\pgfqpoint{\tqft@width}{0pt}}{\pgfqpoint{0pt}{\tqft@depth}}
  } 
%    \end{macrocode}
% We draw the upper and lower arcs again with the appropriate styles
%    \begin{macrocode}
  \beforebackgroundpath{
  \iftqft@within@node
  \else
    \tikz@mode@fillfalse%
    \tikz@mode@drawfalse%
    \let\tikz@mode=\pgfutil@empty
    \let\tikz@options=\pgfutil@empty
    {
    \pgfsys@beginscope
      \tqftset{boundary lower style contents}
      \tikz@mode
      \tikz@options
      \pgfpathmoveto{\pgfqpoint{\tqft@width}{0pt}}
      \pgfpatharc{0}{\pgf@tqft@lower180}{\tqft@width and \tqft@depth}
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@fill fill,\fi%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
      \pgfsys@endscope
    }
    {
      \pgfsys@beginscope
      \tqftset{boundary upper style contents}
      \tikz@mode
      \tikz@options
      \pgfpathmoveto{\pgfqpoint{\tqft@width}{0pt}}
      \pgfpatharc{0}{\pgf@tqft@upper180}{\tqft@width and \tqft@depth}
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@fill fill,\fi%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
      \pgfsys@endscope
    }
    \fi
  }
  }
%    \end{macrocode}
% \end{macro}
% \iffalse
%</package>
% \fi
%
% \subsection{New Version: Picture Shapes}
%
% \iffalse
%<*library>
% \fi
%
% Issue a warning if the pic syntax is not available.
%
%    \begin{macrocode}
\ifcsname pgfk@/handlers/.pic/.@cmd\endcsname
\else
\pgfwarning{This library only works with TikZ 3.0 or later; for earlier versions of TikZ use the TQFT package}
\fi
%    \end{macrocode}
% For the boundaries, we need elliptical node shapes.
%    \begin{macrocode}
\usetikzlibrary{shapes.geometric}
%    \end{macrocode}
% We can view the cobordisms from the \emph{input} or \emph{output} ends, the implementation of the choice is to draw an arc from 0 to 180 or from 0 to -180 so we just need to track minus signs.
% These macros are for that.
%    \begin{macrocode}
\def\pgf@tqft@minus{-}
\let\pgf@tqft@upper\@empty
\let\pgf@tqft@lower\pgf@tqft@minus
%    \end{macrocode}
% Split an anchoring coordinate.
% The \(y\)--value is simply multiplied by the cobordism height (but pointing downwards, so that \(1\) is level with the outgoing boundary).
% The \(x\)--value is multiplied by the boundary separation, but is shifted so that at the incoming boundary level, or above, then it is in line with the incoming boundaries and similarly at the outgoing boundary level, or below, it is in line with the outgoing boundaries.
%    \begin{macrocode}
\def\tqft@split(#1,#2){%
  \pgfmathsetmacro\tqft@y{#2 * (-\tqft@val{cobordism height})}%
  \pgfmathsetmacro\tqft@x{(#1 - 1 + max(min(#2,1),0)*\tqft@val{offset}) * \tqft@val{boundary separation}}%
  \def\tqft@shift{(\tqft@x pt, \tqft@y pt)}%
}%
%    \end{macrocode}
% Now we set up all the keys that we'll need in the course of this shape
%    \begin{macrocode}
\tikzset{
%    \end{macrocode}
% Fix for the fact that the \verb+alias+ key doesn't use the prefix and suffix.
%    \begin{macrocode}
    pic alias/.code={%
      \tikz@fig@mustbenamed
      \expandafter\def\expandafter\tikz@alias\expandafter{\tikz@alias\pgfnodealias{\tikz@pp@name{#1}}{\tikz@fig@name}}%
    },
%    \end{macrocode}
% This key is our basic installer key, setting the pic and putting us in the right key family.
%    \begin{macrocode}
  tqft/.style={%
    pic type=cobordism,
    every tqft/.try,
    tqft/.cd,
  },
%    \end{macrocode}
% This deals with unknown keys, passing them on to TikZ.
%    \begin{macrocode}
  tqft/.unknown/.code={%
    \let\tqft@searchname=\pgfkeyscurrentname%
    \pgfkeysalso{%
      /tikz/\tqft@searchname={#1}
    }
  },
%    \end{macrocode}
% Let's play happy families!
%    \begin{macrocode}
  tqft/.cd,
%    \end{macrocode}
% These set our number of boundary components and genus.
%    \begin{macrocode}
  incoming boundary components/.initial=5,
  outgoing boundary components/.initial=4,
  genus/.initial = 0,
%    \end{macrocode}
% This is the ``horizontal'' offset of the first outgoing component from the first incoming one.
%    \begin{macrocode}
  offset/.initial=0,
%    \end{macrocode}
% This is the ``vertical'' separation between boundary components.
%    \begin{macrocode}
  cobordism height/.initial=2cm,
%    \end{macrocode}
% This is the ``horizontal'' separation between boundary components.
%    \begin{macrocode}
  boundary separation/.initial=2cm,
%    \end{macrocode}
% These are the ``horizontal'' and ``vertical'' radii, respectively, of the boundary components.
%    \begin{macrocode}
  circle x radius/.initial=10pt,
  circle y radius/.initial=5pt,
%    \end{macrocode}
% These control the direction from which we view the cobordism.
%    \begin{macrocode}
  view from/.is choice,
  view from/incoming/.code={%
    \let\pgf@tqft@upper\pgf@tqft@minus
    \let\pgf@tqft@lower\@empty
  },
  view from/outgoing/.code={%
  \let\pgf@tqft@lower\pgf@tqft@minus
    \let\pgf@tqft@upper\@empty
  },
%    \end{macrocode}
% We simulate node placement using the following key.
%    \begin{macrocode}
  anchor/.initial = none,
%    \end{macrocode}
% The next set of keys define some default shapes.
%    \begin{macrocode}
  pair of pants/.style={
    /tikz/tqft,
    incoming boundary components=1,
    outgoing boundary components=2,
    offset=-.5
  },
  /tikz/tqft pair of pants/.style={
    /tikz/tqft/pair of pants,
  },
  reverse pair of pants/.style={
    /tikz/tqft,
    incoming boundary components=2,
    outgoing boundary components=1,
    offset=.5
  },
  /tikz/tqft reverse pair of pants/.style={
    /tikz/tqft/reverse pair of pants,
  },
  cylinder to prior/.style={
    /tikz/tqft,
    incoming boundary components=1,
    outgoing boundary components=1,
    offset=-.5
  },
  /tikz/tqft cylinder to prior/.style={
    /tikz/tqft/cylinder to prior,
  },
  cylinder to next/.style={
    /tikz/tqft,
    incoming boundary components=1,
    outgoing boundary components=1,
    offset=.5
  },
  /tikz/tqft cylinder to next/.style={
    /tikz/tqft/cylinder to next,
  },
  cylinder/.style={
    /tikz/tqft,
    incoming boundary components=1,
    outgoing boundary components=1
  },
  /tikz/tqft cylinder/.style={
    /tikz/tqft/cylinder,
  },
  cup/.style={
    /tikz/tqft,
    incoming boundary components=1,
    outgoing boundary components=0
  },
  /tikz/tqft cup/.style={
    /tikz/tqft/cup,
  },
  cap/.style={
    /tikz/tqft,
    incoming boundary components=0,
    outgoing boundary components=1
  },
  /tikz/tqft cap/.style={
    /tikz/tqft/cap,
  },
}
%    \end{macrocode}
%
% This is a little helper macro for getting the values of tqft keys.
%    \begin{macrocode}
\def\tqft@val#1{\pgfkeysvalueof{/tikz/tqft/#1}}
%    \end{macrocode}
%
% Now we define the code for the actual cobordism shape.
%    \begin{macrocode}
\tikzset{
  cobordism/.pic={
%    \end{macrocode}
% Defining the cobordism paths.
% This holds the full boundary path of the cobordism shape.
%    \begin{macrocode}
      \gdef\tqft@fullpath{}%
%    \end{macrocode}
% This is a list of the edge pieces without the boundary circles.
%    \begin{macrocode}
      \global\let\tqft@blist\pgfutil@gobble%
%    \end{macrocode}
% This punches the holes (if there are any) in the cobordism shape.
%    \begin{macrocode}
      \gdef\tqft@gclip{}%
%    \end{macrocode}
% This is a list of the paths for drawing the holes.
%    \begin{macrocode}
      \global\let\tqft@glist\pgfutil@gobble%
%    \end{macrocode}
% This collects any coordinates that are to be defined (it appears to be difficult to define them as we go along).
%    \begin{macrocode}
      \global\let\tqft@clist\pgfutil@gobble%
%    \end{macrocode}
% This collects any coordinates that can be used to shift the shape that aren't to be defined using \verb+\tqft@clist+.
%    \begin{macrocode}
      \global\let\tqft@alist\pgfutil@gobble
%    \end{macrocode}
% The first stage is to iterate over the incoming boundary components (if there are any), building up the various paths.
%    \begin{macrocode}
      \ifnum\tqft@val{incoming boundary components}>0\relax
%    \end{macrocode}
% We have some so draw the half circle for the first component.
% Note that we use \verb+\pgf@tqft@upper+ to flip the sign of the start angle depending on the \verb+view from+ setting.
%    \begin{macrocode}
      \xdef\tqft@fullpath{%
        \tqft@fullpath
        (-\tqft@val{circle x radius},0) arc[start angle=\pgf@tqft@upper180, end angle=0, x radius=\tqft@val{circle x radius}, y radius=\tqft@val{circle y radius}]
      }%
%    \end{macrocode}
% And add the centre to the list for available shifts.
%    \begin{macrocode}
      \xdef\tqft@alist{%
        \tqft@alist,-incoming boundary 1/{(0,0)},-incoming boundary/{(0,0)}%
      }%
%    \end{macrocode}
% If there are more than one then for each subsequent one we add the curve between them and the corresponding arc of the boundary circle.
%    \begin{macrocode}
      \ifnum\tqft@val{incoming boundary components}>1\relax
      \foreach[
        evaluate=\k as \xpos using (\k-1)*\tqft@val{boundary separation} -\tqft@val{circle x radius},
        evaluate=\k as \xppos using (\k-2)*\tqft@val{boundary separation} +\tqft@val{circle x radius},
        evaluate=\k as \cpos using (\k-1.5)*\tqft@val{boundary separation},
        evaluate=\k as \kmo using int(\k-1)
      ] \k in {2,...,\tqft@val{incoming boundary components}} {
%    \end{macrocode}
% Add the curve and the arc.
%    \begin{macrocode}
        \xdef\tqft@fullpath{%
          \tqft@fullpath
           .. controls +(0,-\tqft@val{cobordism height}/3) and +(0,-\tqft@val{cobordism height}/3) ..  (\xpos pt,0) arc[start angle=\pgf@tqft@upper180, end angle=0, x radius=\tqft@val{circle x radius}, y radius=\tqft@val{circle y radius}]
      }%
%    \end{macrocode}
% But for the edge path, just add the curve to the list.
%    \begin{macrocode}
        \xdef\tqft@blist{%
          \tqft@blist,incoming boundary \k/incoming/{%
      (\xppos pt,0) .. controls +(0,-\tqft@val{cobordism height}/3) and +(0,-\tqft@val{cobordism height}/3) .. (\xpos pt,0)}%
      }%
%    \end{macrocode}
% We add a coordinate at the midpoint of the curve.
%    \begin{macrocode}
      \xdef\tqft@clist{%
        \tqft@clist,-between incoming \kmo\space and \k/{(\cpos pt,-\tqft@val{cobordism height}/4)}%
      }%
%    \end{macrocode}
% And add the centre to the list for available shifts.
%    \begin{macrocode}
      \xdef\tqft@alist{%
        \tqft@alist,-incoming boundary \k/{(\kmo * \tqft@val{boundary separation},0)}%
      }%
      }%
      \fi
%    \end{macrocode}
% We're at the edge of the last incoming boundary component.
% What we do now depends on whether or not there are outgoing boundary components.
%    \begin{macrocode}
      \ifnum\tqft@val{outgoing boundary components}>0\relax
%    \end{macrocode}
% There are, so we add a curve from the end of the last incoming to the last outgoing component to the full path,
%    \begin{macrocode}
        \pgfmathsetmacro\xppos{(\tqft@val{outgoing boundary components} -1+\tqft@val{offset}) * \tqft@val{boundary separation} +\tqft@val{circle x radius}}%
      \pgfmathsetmacro\tqft@ht{abs(\tqft@val{incoming boundary components} - \tqft@val{outgoing boundary components} - \tqft@val{offset})}%
      \pgfmathsetmacro\tqft@ht{1/3 + 2/3*\tqft@ht/(\tqft@ht + 1)}%
      \xdef\tqft@fullpath{%
        \tqft@fullpath
        .. controls +(0,-\tqft@ht*\tqft@val{cobordism height}) and +(0,\tqft@ht*\tqft@val{cobordism height}) .. (\xppos pt, -\tqft@val{cobordism height})
      }%
%    \end{macrocode}
% and the edge path.
%    \begin{macrocode}
      \xdef\tqft@blist{%
        \tqft@blist,between last incoming and last outgoing/incoming and outgoing/{%
        (\tqft@val{incoming boundary components} * \tqft@val{boundary separation} + \tqft@val{circle x radius} - \tqft@val{boundary separation},0pt)
        .. controls +(0,-\tqft@ht*\tqft@val{cobordism height}) and +(0,\tqft@ht*\tqft@val{cobordism height}) .. (\xppos pt, -\tqft@val{cobordism height})}%
      }%
%    \end{macrocode}
% In addition, we add a coordinate at the midpoint.
%    \begin{macrocode}
      \pgfmathsetmacro\xppos{(\xppos + (\tqft@val{incoming boundary components} -1) * \tqft@val{boundary separation} +\tqft@val{circle x radius})/2}%
      \xdef\tqft@clist{%
        \tqft@clist,-between last incoming and last outgoing/{(\xppos pt,-\tqft@val{cobordism height}/2)}%
      }%
      \else
%    \end{macrocode}
% There aren't any outgoing boundary components so we loop back to the start.
% We adjust the height of the control points to take into account the overall width.
%    \begin{macrocode}
      \pgfmathsetmacro\tqft@ht{1/3 + 2/3*(\tqft@val{incoming boundary components} - 1)/\tqft@val{incoming boundary components}}
      \xdef\tqft@fullpath{%
        \tqft@fullpath
        .. controls +(0,-\tqft@ht*\tqft@val{cobordism height}) and +(0,-\tqft@ht*\tqft@val{cobordism height}) .. (-\tqft@val{circle x radius},0)
      }%
%    \end{macrocode}
% Same for the edge path.
%    \begin{macrocode}
      \xdef\tqft@blist{%
        \tqft@blist,between first incoming and last incoming/incoming and outgoing/{%
        (\tqft@val{incoming boundary components} * \tqft@val{boundary separation} + \tqft@val{circle x radius} - \tqft@val{boundary separation},0pt)
        .. controls +(0,-\tqft@ht*\tqft@val{cobordism height}) and +(0,-\tqft@ht*\tqft@val{cobordism height}) .. (-\tqft@val{circle x radius},0)}
      }%
%    \end{macrocode}
% Add a coordinate at the midpoint.
%    \begin{macrocode}
      \pgfmathsetmacro\xppos{(\tqft@val{incoming boundary components} -1) * \tqft@val{boundary separation}/2}%
      \xdef\tqft@clist{%
        \tqft@clist,-between first incoming and last incoming/{(\xppos pt,-\tqft@ht*\tqft@val{cobordism height}*3/4)}%
      }%
      \fi
      \else
%    \end{macrocode}
% There weren't any incoming boundary components, so we test to see if there were any outgoing ones and move to the start of them.
%    \begin{macrocode}
      \ifnum\tqft@val{outgoing boundary components}>0\relax
        \pgfmathsetmacro\xppos{(\tqft@val{outgoing boundary components} -1+\tqft@val{offset}) * \tqft@val{boundary separation} +\tqft@val{circle x radius}}
%    \end{macrocode}
% Add a move to the full path,
%    \begin{macrocode}
      \xdef\tqft@fullpath{%
        \tqft@fullpath
        (\xppos pt, -\tqft@val{cobordism height})
      }%
      \fi
      \fi
%    \end{macrocode}
% We're done with the incoming boundary components, now we're set up for the outgoing ones.
% However we got there, if we have outgoing boundary components then we're now located at the start of them, although we're counting backwards.
%    \begin{macrocode}
      \ifnum\tqft@val{outgoing boundary components}>0\relax
      \pgfmathsetmacro\xppos{(\tqft@val{outgoing boundary components} -1+\tqft@val{offset}) * \tqft@val{boundary separation} -\tqft@val{circle x radius}}%
%    \end{macrocode}
% Draw the arc for the first (well, last actually) boundary component.
%    \begin{macrocode}
      \xdef\tqft@fullpath{%
        \tqft@fullpath
        arc[end angle=\pgf@tqft@upper180, start angle=0, x radius=\tqft@val{circle x radius}, y radius=\tqft@val{circle y radius}]
      }%
%    \end{macrocode}
% And add the centre to the list for available shifts.
%    \begin{macrocode}
      \xdef\tqft@alist{%
        \tqft@alist,-outgoing boundary \tqft@val{outgoing boundary components}/{(\xppos pt + \tqft@val{circle x radius},-\tqft@val{cobordism height})},-outgoing boundary/{(\tqft@val{offset}*\tqft@val{boundary separation},-\tqft@val{cobordism height})}%
      }%
%    \end{macrocode}
% Do we have more than one boundary component?
%    \begin{macrocode}
      \ifnum\tqft@val{outgoing boundary components}>1\relax
%    \end{macrocode}
% Yes, so add a curve and arc for each.
%    \begin{macrocode}
      \foreach[
        evaluate=\k as \xpos using (\tqft@val{outgoing boundary components} - \k + \tqft@val{offset})*\tqft@val{boundary separation} + \tqft@val{circle x radius},
        evaluate=\k as \xppos using (\tqft@val{outgoing boundary components} - \k + 1 + \tqft@val{offset})*\tqft@val{boundary separation} - \tqft@val{circle x radius},
        evaluate=\k as \cpos using (\tqft@val{outgoing boundary components} - \k + .5 + \tqft@val{offset})*\tqft@val{boundary separation},
        evaluate=\k as \nk using int(\tqft@val{outgoing boundary components} - \k + 1),
        evaluate=\k as \nkpo using int(\tqft@val{outgoing boundary components} - \k + 2),
      ] \k in {2,...,\tqft@val{outgoing boundary components}} {
%    \end{macrocode}
% Both are added to the full path.
%    \begin{macrocode}
        \xdef\tqft@fullpath{%
          \tqft@fullpath
           .. controls +(0,\tqft@val{cobordism height}/3) and +(0,\tqft@val{cobordism height}/3) ..  (\xpos pt,-\tqft@val{cobordism height}) arc[end angle=\pgf@tqft@upper180, start angle=0, x radius=\tqft@val{circle x radius}, y radius=\tqft@val{circle y radius}]
      }%
%    \end{macrocode}
% Just the arc for the edge paths.
%    \begin{macrocode}
        \xdef\tqft@blist{%
          \tqft@blist,between outgoing \nk\space and \nkpo/outgoing/{%
 (\xppos pt,-\tqft@val{cobordism height})
           .. controls +(0,\tqft@val{cobordism height}/3) and +(0,\tqft@val{cobordism height}/3) ..  (\xpos pt,-\tqft@val{cobordism height}) ++(-2*\tqft@val{circle x radius},0)}%
      }%
%    \end{macrocode}
% And a coordinate at the midpoint.
%    \begin{macrocode}
      \xdef\tqft@clist{%
        \tqft@clist,-between outgoing \nk\space and \nkpo/{(\cpos pt,-3*\tqft@val{cobordism height}/4)}%
      }%
%    \end{macrocode}
% And add the centre to the list for available shifts.
%    \begin{macrocode}
      \xdef\tqft@alist{%
        \tqft@alist,-outgoing boundary \nk/{(\xpos pt - \tqft@val{circle x radius},-\tqft@val{cobordism height})}%
      }%
      }%
      \fi
%    \end{macrocode}
% Now we're at the end of the outgoing boundary components (well, the start actually).
% What we do now depends on whether or not there are any incoming boundary components.
%    \begin{macrocode}
      \ifnum\tqft@val{incoming boundary components}>0\relax
%    \end{macrocode}
% There are, so we draw the path back up.
%    \begin{macrocode}
      \pgfmathsetmacro\tqft@ht{1/3 + 2/3*abs(\tqft@val{offset})/(abs(\tqft@val{offset}) + 1)}%
      \xdef\tqft@fullpath{%
        \tqft@fullpath
        .. controls +(0,\tqft@ht*\tqft@val{cobordism height}) and +(0,-\tqft@ht*\tqft@val{cobordism height}) .. (-\tqft@val{circle x radius},0)
      }%
%    \end{macrocode}
% And the edge path does the same.
%    \begin{macrocode}
      \xdef\tqft@blist{%
        \tqft@blist,between first incoming and first outgoing/incoming and outgoing/{%
    (\tqft@val{offset} * \tqft@val{boundary separation} - \tqft@val{circle x radius},-\tqft@val{cobordism height})
        .. controls +(0,\tqft@ht*\tqft@val{cobordism height}) and +(0,-\tqft@ht*\tqft@val{cobordism height}) .. (-\tqft@val{circle x radius},0)}%
      }%
%    \end{macrocode}
% Add a coordinate at the midpoint.
%    \begin{macrocode}
      \xdef\tqft@clist{%
        \tqft@clist,-between first incoming and first outgoing/{(\tqft@val{offset}*\tqft@val{boundary separation}/2-\tqft@val{circle x radius},-\tqft@val{cobordism height}/2)}%
      }%
      \else
%    \end{macrocode}
% No incoming boundary components so loop back to the other end of the outgoing boundary components.
%    \begin{macrocode}
      \pgfmathsetmacro\xppos{(\tqft@val{outgoing boundary components} -1+\tqft@val{offset}) * \tqft@val{boundary separation} +\tqft@val{circle x radius}}%
      \pgfmathsetmacro\tqft@ht{1/3 + 2/3*(\tqft@val{outgoing boundary components} - 1)/\tqft@val{outgoing boundary components}}
%    \end{macrocode}
% Full path.
%    \begin{macrocode}
      \xdef\tqft@fullpath{%
        \tqft@fullpath
        .. controls +(0,\tqft@ht*\tqft@val{cobordism height}) and +(0,\tqft@ht*\tqft@val{cobordism height}) .. (\xppos pt,-\tqft@val{cobordism height})
      }%
%    \end{macrocode}
% Edge path.
%    \begin{macrocode}
      \xdef\tqft@blist{%
        \tqft@blist,between first and last outgoing/incoming and outgoing/{%
    (\tqft@val{offset} * \tqft@val{boundary separation} - \tqft@val{circle x radius},-\tqft@val{cobordism height})
        .. controls +(0,\tqft@ht*\tqft@val{cobordism height}) and +(0,\tqft@ht*\tqft@val{cobordism height}) .. (\xppos pt,-\tqft@val{cobordism height})}%
      }%
%    \end{macrocode}
% Add a coordinate at the midpoint.
%    \begin{macrocode}
      \pgfmathsetmacro\xppos{(\tqft@val{outgoing boundary components}/2 + \tqft@val{offset} -1/2) * \tqft@val{boundary separation}}%
      \pgfmathsetmacro\tqft@ht{1 -\tqft@ht*3/4}%
      \xdef\tqft@clist{%
        \tqft@clist,-between first and last outgoing/{(\xppos pt,-\tqft@ht*\tqft@val{cobordism height})}%
      }%
      \fi
      \fi
%    \end{macrocode}
% Now we define the clip path for the genus holes.
% We start with a big rectangle that \emph{ought} to be big enough to contain the whole shape.
% We start with the top left corner.
%    \begin{macrocode}
      \pgfmathsetmacro\xpos{%
        (
        \tqft@val{outgoing boundary components} > 0 ? 
        (
        \tqft@val{incoming boundary components} > 0 ?
        min(0,\tqft@val{offset}) : \tqft@val{offset}
        ) : 0
        )
        *\tqft@val{boundary separation} - 2*\tqft@val{circle x radius}}%
      \xdef\tqft@gclip{(\xpos pt,2*\tqft@val{circle y radius}) rectangle }%
%    \end{macrocode}
% Now the bottom right.
%    \begin{macrocode}
      \pgfmathsetmacro\xpos{%
        ((
        \tqft@val{outgoing boundary components} > 0 ? 
        (
        \tqft@val{incoming boundary components} > 0 ?
        max(\tqft@val{incoming boundary components},\tqft@val{outgoing boundary components} + \tqft@val{offset}) : \tqft@val{outgoing boundary components} + \tqft@val{offset}
        ) : \tqft@val{incoming boundary components}
        )-1)
        *\tqft@val{boundary separation} + 2*\tqft@val{circle x radius}}%
%    \end{macrocode}
% Together, these make a rectangle.
%    \begin{macrocode}
      \xdef\tqft@gclip{\tqft@gclip (\xpos pt,-\tqft@val{cobordism height} - 2*\tqft@val{circle y radius})}%
%    \end{macrocode}
% Are there any holes?
%    \begin{macrocode}
      \ifnum\tqft@val{genus}>0\relax
%    \end{macrocode}
% Yes, so first we need to figure out where to place them.
% We work out the left-hand edge of the cobordism.
%    \begin{macrocode}
      \pgfmathsetmacro\xpos{%
        (
        \tqft@val{outgoing boundary components} > 0 ? 
        (
        \tqft@val{incoming boundary components} > 0 ?
        \tqft@val{offset}/2 : \tqft@val{offset}
        ) : 0
        )
        *\tqft@val{boundary separation} - \tqft@val{circle x radius}}%
%    \end{macrocode}
% Work out the height that the holes should be punched at.
%    \begin{macrocode}
      \pgfmathsetmacro\ypos{%
        (
        \tqft@val{outgoing boundary components} > 0 ? 
        (
        \tqft@val{incoming boundary components} > 0 ?
        -\tqft@val{cobordism height}/2 : -1 + \tqft@val{cobordism height}/3
        ) : - \tqft@val{cobordism height}/3
        )}%
%    \end{macrocode}
% Start our clip path at this point
%    \begin{macrocode}
      \xdef\tqft@gclip{%
        \tqft@gclip
        (\xpos pt,\ypos pt)
      }%
%    \end{macrocode}
% Now work out the width of the cobordism, in units of circle half-widths.
% This may not be very accurate if there aren't any boundary components of a given type.
%    \begin{macrocode}
      \pgfmathsetmacro\gsize{%
        ((
        \tqft@val{outgoing boundary components} > 0 ? 
        (
        \tqft@val{incoming boundary components} > 0 ?
        (\tqft@val{incoming boundary components} + \tqft@val{outgoing boundary components})/2 : \tqft@val{outgoing boundary components}
        ) : \tqft@val{incoming boundary components}
        )-1)
        *\tqft@val{boundary separation}/\tqft@val{circle x radius} + 2}%
%    \end{macrocode}
% Each hole should take up three half-widths, but we want a little extra on the edges so the total number of half-widths we want is \(3g + 1\).
% Do we need to scale down the holes (we never scale up)?
% If so, \verb+\gscale+ holds the overall scale factor and \verb+\gxscale+ and \verb+gyscale+ are the resulting horizontal and vertical measurements.
% The baseline is the size of the boundary circles.
%    \begin{macrocode}
      \pgfmathsetmacro\gscale{min(1,\gsize/(3*\tqft@val{genus}+1))}%
      \pgfmathsetmacro\gyscale{\tqft@val{circle y radius}*\gscale*.707}%
      \pgfmathsetmacro\gxscale{\tqft@val{circle x radius}*\gscale}%
%    \end{macrocode}
% Each hole should take up 2 half widths, modulo scaling, so the total width used by the holes is \(2 g s\) leaving \(w - 2 g s\) left for the gaps which is divided in to \(g + 1\) lots.
%    \begin{macrocode}
      \pgfmathsetmacro\gsep{((\gsize - 2*\tqft@val{genus}*\gscale)/(\tqft@val{genus} + 1)*\tqft@val{circle x radius}}%
%    \end{macrocode}
% We shift in by half of one unit of excess separation.
%    \begin{macrocode}
      \xdef\tqft@gclip{%
        \tqft@gclip
        ++(\gsep/2 pt,0)
      }%
%    \end{macrocode}
% Some useful quantities.
%    \begin{macrocode}
      \pgfmathsetmacro\omrstwo{1 - 1/sqrt(2)}%
      \pgfmathsetmacro\sqrtwo{sqrt(2)}%
%    \end{macrocode}
% Now we iterate over the holes.
%    \begin{macrocode}
      \foreach[
        evaluate=\k as \kmo using int(2 * \k-1)
      ] \k in {1,...,\tqft@val{genus}} {
%    \end{macrocode}
% For the clipping path, we just want the bare hole.
%    \begin{macrocode}
        \xdef\tqft@gclip{%
          \tqft@gclip
%    \end{macrocode}
% Move in by half an excess separation unit and move to the left-hand extent of the hole.
%    \begin{macrocode}
          ++(\gsep/2 pt + \omrstwo*\gxscale pt,0)
%    \end{macrocode}
% Now curve up over the hole,
%    \begin{macrocode}
          .. controls +(\gxscale*\sqrtwo/3 pt,4/3*\gyscale pt) and +(-\gxscale*\sqrtwo/3 pt,4/3*\gyscale pt)
          .. ++(\sqrtwo*\gxscale pt,0)
%    \end{macrocode}
% and return on the underside.
%    \begin{macrocode}
          .. controls +(-\gxscale*\sqrtwo/3 pt,-4/3*\gyscale pt) and +(\gxscale*\sqrtwo/3 pt,-4/3*\gyscale pt)
          .. ++(-\sqrtwo*\gxscale pt,0)
%    \end{macrocode}
% Lastly, move to the right-hand edge of the space taken up by this hole.
%    \begin{macrocode}
          ++(2*\gxscale pt -\omrstwo*\gxscale pt + \gsep/2 pt,0)
        }
%    \end{macrocode}
% For the genus \emph{path} we want to add the little ``tails'' which means that the two curves are different, and we need to take into acount the \verb+view from+ direction.
%    \begin{macrocode}
        \xdef\tqft@glist{%
          \tqft@glist,%
            hole \k/lower/{%
%    \end{macrocode}
% Move to the starting point of the smaller curve and add that.
%    \begin{macrocode}
            (\xpos pt + \k * \gsep pt +  \kmo * \gxscale pt + \gxscale pt -\omrstwo*\gxscale pt,\ypos pt)
          .. controls +(-\gxscale pt*\sqrtwo/3,\pgf@tqft@upper4/3*\gyscale pt) and +(\gxscale pt*\sqrtwo/3,\pgf@tqft@upper4/3*\gyscale pt)
          .. ++(-\sqrtwo*\gxscale pt,0)},%
% Move to the left-hand corner of the path, with the upper or lower chosen by the \verb+view from+ direction.
          hole \k/upper/{(\xpos pt + \k * \gsep pt +  \kmo * \gxscale pt - \gxscale pt,\ypos pt + \pgf@tqft@upper\gyscale pt)%
%    \end{macrocode}
% Add the larger of the two curves.
%    \begin{macrocode}
          .. controls +(\gxscale pt*2/3,\pgf@tqft@lower8/3*\gyscale pt) and +(-\gxscale pt*2/3,\pgf@tqft@lower8/3*\gyscale pt)
          .. ++(2*\gxscale pt,0)}%
        }%
%    \end{macrocode}
% Add a coordinate at the centre of the hole.
%    \begin{macrocode}
        \xdef\tqft@clist{%
          \tqft@clist,-hole \k/{(\xpos pt + \k * \gsep pt +  \kmo * \gxscale pt,\ypos pt)}%
        }%
      }%
      \fi
%    \end{macrocode}
% Now we start to lay out the cobordism
% Were we given a shift?  If so, shift.
%    \begin{macrocode}
\gdef\tqft@shift{(0,0)}%
\edef\tqft@anchor{\tqft@val{anchor}}%
\expandafter\pgfutil@in@\expandafter{\expandafter,\expandafter}\expandafter{\tqft@anchor}%
\ifpgfutil@in@
\expandafter\tqft@split\tqft@anchor\relax
\else
\edef\tqft@anchor{-\tqft@val{anchor}}%
\xdef\tqft@alist{\tqft@clist,\tqft@alist}%
\foreach \anchor/\coord in \tqft@alist
{
  \ifx\anchor\tqft@anchor\relax
  \global\let\tqft@shift\coord
  \fi
}%
\fi
\tikz@scan@one@point\pgfutil@firstofone\tqft@shift\relax
\begin{scope}[shift={(-\pgf@x,-\pgf@y)}]
%    \end{macrocode}
% At each incoming boundary component we place an elliptical node of the right size.
%    \begin{macrocode}
      \ifnum\tqft@val{incoming boundary components}>0\relax
      \foreach[evaluate=\k as \xpos using (\k-1)*\tqft@val{boundary separation}] \k in {1,...,\tqft@val{incoming boundary components}} {
        \node[
          node contents={},
          ellipse,
          inner sep=0pt,
          outer sep=0pt,
          minimum width=2*\tqft@val{circle x radius},
          minimum height=2*\tqft@val{circle y radius},
          at={(\xpos pt,0)},
          name=-incoming boundary \k,
          /tikz/tqft/every boundary component/.try,
          /tikz/tqft/every incoming boundary component/.try,
          /tikz/tqft/incoming boundary component \k/.try
        ];
      }%
%    \end{macrocode}
% Add an alias for the first.
%    \begin{macrocode}
      \path node also[pic alias=-incoming boundary] (-incoming boundary 1);
      \fi
%    \end{macrocode}
% Same for the outgoing boundary components.
%    \begin{macrocode}
      \ifnum\tqft@val{outgoing boundary components}>0\relax
      \foreach[
        evaluate=\k as \xpos using (\k-1+\tqft@val{offset})*\tqft@val{boundary                   separation}
      ] \k in {1,...,\tqft@val{outgoing boundary components}} {
          \node[
          node contents={},
          ellipse,
          inner sep=0pt,
          outer sep=0pt,
          minimum width=2*\tqft@val{circle x radius},
          minimum height=2*\tqft@val{circle y radius},
          at={(\xpos pt,-\tqft@val{cobordism height})},
          name=-outgoing boundary \k,
          /tikz/tqft/every boundary component/.try,
          /tikz/tqft/every outgoing boundary component/.try,
          /tikz/tqft/outgoing boundary component \k/.try
        ];
      }%
%    \end{macrocode}
% Add an alias for the first.
%    \begin{macrocode}
      \path node also[pic alias=-outgoing boundary] (-outgoing boundary 1);
      \fi
%    \end{macrocode}
% Now we draw the lower paths of the incoming boundary components.
%    \begin{macrocode}
      \ifnum\tqft@val{incoming boundary components}>0\relax
      \foreach[evaluate=\k as \xpos using (\k-1)*\tqft@val{boundary separation}] \k in {1,...,\tqft@val{incoming boundary components}} {
        \path[
          /tikz/tqft/every lower boundary component/.try,
          /tikz/tqft/every incoming lower boundary component/.try,
          /tikz/tqft/incoming lower boundary component \k/.try
        ] (\xpos pt - \tqft@val{circle x radius},0) arc[start angle=\pgf@tqft@lower180,end angle=0, x radius=\tqft@val{circle x radius}, y radius =\tqft@val{circle y radius}];
      }%
      \fi
%    \end{macrocode}
% Same for the outgoing boundary components.
%    \begin{macrocode}
      \ifnum\tqft@val{outgoing boundary components}>0\relax
      \foreach[
        evaluate=\k as \xpos using (\k-1+\tqft@val{offset})*\tqft@val{boundary                   separation}
      ] \k in {1,...,\tqft@val{outgoing boundary components}} {
        \path[
          /tikz/tqft/every lower boundary component/.try,
          /tikz/tqft/every outgoing lower boundary component/.try,
          /tikz/tqft/outgoing lower boundary component \k/.try
        ] (\xpos pt - \tqft@val{circle x radius},-\tqft@val{cobordism height}) arc[start angle=\pgf@tqft@lower180,end angle=0, x radius=\tqft@val{circle x radius}, y radius =\tqft@val{circle y radius}];
        }%
      \fi
%    \end{macrocode}
% Full outer path, clipped against the genus holes in case it is filled.
%    \begin{macrocode}
      \begin{scope}
      \path[overlay,clip] \tqft@gclip;
      \path[
        /tikz/tqft/cobordism/.try,
        pic actions,
        /tikz/tqft/cobordism outer path/.try,
      ] \tqft@fullpath;
      \end{scope}
%    \end{macrocode}
% Now we draw the genus path, outside the clip.
% We view this as part of the full cobordism path so try to apply the same style as for the full path, but if that is filled then we turn the fill off.
% It can be turned back on again using the styles \verb+cobordism edge+ or \verb+genus style+.
% We also apply the \verb+cobordism edge+ style as it could be thought of as part of the non-boundary edge.
% Finally, it has its own style to enable overrides if the other two get confused.
%    \begin{macrocode}
\ifx\tqft@glist\pgfutil@gobble
\else
\foreach \tqft@gstyle/\tqft@gside/\tqft@gpath in \tqft@glist {
      \path[
        /tikz/tqft/cobordism/.try,
        pic actions,
        fill=none,
        shade=none,
        /tikz/tqft/cobordism edge/.try,
        /tikz/tqft/genus style/.try,
        /tikz/tqft/genus \tqft@gside/.try,
        /tikz/tqft/\tqft@gstyle/.try,
        /tikz/tqft/\tqft@gstyle\space\tqft@gside/.try,
      ] \tqft@gpath;
}
\fi
%    \end{macrocode}
% Now we redraw the non-boundary paths.
%    \begin{macrocode}
\ifx\tqft@blist\pgfutil@gobble
\else
\foreach \tqft@bstyle/\tqft@btype/\tqft@bpath in \tqft@blist {
      \path[
        /tikz/tqft/cobordism edge/.try,
        /tikz/tqft/cobordism outer edge/.try,
        /tikz/tqft/between \tqft@btype/.try,
        /tikz/tqft/\tqft@bstyle/.try,
      ] \tqft@bpath;
}
\fi
%    \end{macrocode}
% There were various coordinates that we wanted to define but couldn't.
% Here, we put those in place.
%    \begin{macrocode}
      \ifx\tqft@clist\pgfutil@gobble
      \else
      \foreach \name/\coord in \tqft@clist {
        \path \coord node[coordinate,node contents={},name=\name];
      }
      \fi
%    \end{macrocode}
% The last task is to draw the upper paths of the boundary components.
% First, incoming.
%    \begin{macrocode}
      \ifnum\tqft@val{incoming boundary components}>0\relax
      \foreach[evaluate=\k as \xpos using (\k-1)*\tqft@val{boundary separation}] \k in {1,...,\tqft@val{incoming boundary components}} {
        \path[
          /tikz/tqft/every upper boundary component/.try,
          /tikz/tqft/every incoming upper boundary component/.try,
          /tikz/tqft/incoming upper boundary component \k/.try
        ] (\xpos pt - \tqft@val{circle x radius},0) arc[start angle=\pgf@tqft@upper180,end angle=0, x radius=\tqft@val{circle x radius}, y radius =\tqft@val{circle y radius}];
      }
      \fi
%    \end{macrocode}
% Next, outgoing.
%    \begin{macrocode}
      \ifnum\tqft@val{outgoing boundary components}>0\relax
      \foreach[
        evaluate=\k as \xpos using (\k-1+\tqft@val{offset})*\tqft@val{boundary                   separation}
      ] \k in {1,...,\tqft@val{outgoing boundary components}} {
        \path[
          /tikz/tqft/every upper boundary component/.try,
          /tikz/tqft/every outgoing upper boundary component/.try,
          /tikz/tqft/outgoing upper boundary component \k/.try
        ] (\xpos pt - \tqft@val{circle x radius},-\tqft@val{cobordism height}) arc[start angle=\pgf@tqft@upper180,end angle=0, x radius=\tqft@val{circle x radius}, y radius =\tqft@val{circle y radius}];
      }
      \fi
\end{scope}
%    \end{macrocode}
% We're done!
% Phew.
%    \begin{macrocode}
  }
}
%    \end{macrocode}
%
% \iffalse
%</library>
% \fi
% \Finale

\endinput
