% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
tqft --- a style file for drawing TQFT diagrams with TikZ/PGF
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package defines some node shapes useful for drawing TQFT diagrams with TikZ/PGF.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
tqft --- a style file for drawing TQFT diagrams with TikZ/PGF
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2011 by Andrew Stacey <stacey@math.ntnu.no>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Andrew Stacey.

This work consists of the file  tqft.dtx
and the derived files           tqft.ins,
                                tqft.pdf, and
                                tqft.sty.

\endpostamble
\usedir{tex/latex/tqft}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/tqft}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/demopkg}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*package>
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{tqft}[2011/05/03 v1.0 Tikz/PGF commands for drawing TQFT diagrams]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{morefloats}
\usepackage{tikz}
\usepackage{\jobname}
\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{breakatwhitespace=true,breaklines=true,language=TeX}
 
\usepackage{fancyvrb}

\newenvironment{example}
  {\VerbatimEnvironment
   \begin{VerbatimOut}[gobble=2]{example.out}}
  {\end{VerbatimOut}
   \begin{center}
%   \setlength{\parindent}{0pt}
   \fbox{\begin{minipage}{.9\linewidth}
     \lstset{breakatwhitespace=true,breaklines=true,language=TeX,basicstyle=\small}
     \lstinputlisting[]{example.out}
   \end{minipage}}

   \fbox{\begin{minipage}{.9\linewidth}
     \input{example.out}
   \end{minipage}}
\end{center}
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.0}{2011/05/03}{Converted to DTX file}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{tqft.dtx}
% \title{The \textsf{tqft} package}
% \author{Andrew Stacey \\ \url{stacey@math.ntnu.no}}
% \date{\fileversion~from \filedate}
%
% \maketitle
%
%
% \begin{tikzpicture}[every node/.style={tqft/cobordism style={draw,thick,red}}]
% \node[
%   tqft,
%   fill=orange,
%   fill opacity=.5,
%   tqft/boundary style={fill=purple},
%   tqft/cobordism style={draw,thick,red},
%   tqft/boundary lower style={draw,dashed,thick,blue},
%   tqft/boundary upper style={draw,green,thick},
%   tqft/incoming boundary components=4,
%   tqft/outgoing boundary components=6,
%   tqft/offset=-1.5,
% ] (a) {};
% \node[pin=north:1] at (a.incoming boundary 1) {};
% \node[pin=north:3] at (a.incoming boundary 3) {};
% \node[pin=south:1] at (a.outgoing boundary 1) {};
% \node[pin=south:4] at (a.outgoing boundary 4) {};
% \node[pin=south:6] at (a.outgoing boundary 6) {};
% \end{tikzpicture}
%
% \section{Introduction}
%
% This package defines some TikZ/PGF node shapes that can be used to construct the diagrams common in Topological Quantum Field Theory (TQFT).
% An example follows:
%
% \begin{example}
% \begin{center}
% \begin{tikzpicture}
% \node[draw,tqft/pair of pants] (a) {};
% \node[draw,tqft/cylinder to next,anchor=incoming boundary 1] (c) at (a.incoming boundary 2) {};
% \node[draw,tqft/reverse pair of pants, anchor=incoming boundary 1] at (a.outgoing boundary 2) (b) {};
% \end{tikzpicture}
% \end{center}
% \end{example}
%
%
% \section{The Shapes}
%
% There is actually only one shape, \Verb+tqft+.
% It is a cobordism between a number of incoming circles and a number of outgoing circles, where the numbers of boundary components can be specified as options to the shape.
% There are certain common shapes that are predefined as aliases to this shape with specified boundaries.
%
% The list of predefined shapes follows.
%
% \begin{enumerate}
% \item \Verb+tqft/pair of pants+
%
% \begin{tikzpicture}
% \node[draw,tqft/pair of pants] (a) {};
% \end{tikzpicture}
%
% \item \Verb+tqft/reverse pair of pants+
%
% \begin{tikzpicture}
% \node[draw,tqft/reverse pair of pants] (a) {};
% \end{tikzpicture}
%
% \item \Verb+tqft/cylinder to prior+
%
% This is a cylinder that has been skewed to one side, thus following the same path as the \Verb+pair of pants+ cobordism but with only one outgoing boundary component.
% The name \Verb+to prior+ is because it goes towards the lower-numbered component on the \Verb+pair of pants+. 
%
% \begin{tikzpicture}
% \node[draw,tqft/cylinder to prior] (a) {};
% \end{tikzpicture}
%
% \item \Verb+tqft/cylinder to next+
%
% This is a cylinder that has been skewed to one side, thus following the same path as the \Verb+pair of pants+ cobordism but with only one outgoing boundary component.
% The name \Verb+to next+ is because it goes towards the higher-numbered component on the \Verb+pair of pants+. 
%
% \begin{tikzpicture}
% \node[draw,tqft/cylinder to next] (a) {};
% \end{tikzpicture}
%
% \item \Verb+tqft/cylinder+
%
% This is a straight cylinder.
%
% \begin{tikzpicture}
% \node[draw,tqft/cylinder] (a) {};
% \end{tikzpicture}
%
% \item \Verb+tqft/cap+
%
% This is a cap.
%
% \begin{tikzpicture}
% \node[draw,tqft/cap] (a) {};
% \end{tikzpicture}
%
% \item \Verb+tqft/cup+
%
% This is a cup (an upside-down cap).
%
% \begin{tikzpicture}
% \node[draw,tqft/cup] (a) {};
% \end{tikzpicture}
% \end{enumerate}
%
% The general shape is controlled by the following keys:
%
% \begin{itemize}
% \item \DescribeMacro{tqft/flow} A cobordism ``flows'' from its incoming to its outgoing boundaries.
% This key controls the direction of that flow.
% The shape is transformed so that the incoming-outgoing axis aligns with the argument.
% However, the transformation may be more than just a rotation as the shape is set up so that the numbering of the boundary components is always left-to-right or top-to-bottom (as appropriate).
% Currently, this key can take the values \Verb+north+, \Verb+south+ (default), \Verb+east+, and \Verb+west+.
% \item \DescribeMacro{tqft/view from} To get a simulated 3D effect, the cobordism is drawn as if viewed from a slight angle.
% The value of this key determines whether the cobordism is viewed from the direction of the incoming boundary components or the outgoing ones.
% This key can take the values \Verb+incoming+ and \Verb+outgoing+.
% The default is \Verb+outgoing+.
% \item \DescribeMacro{tqft/cobordism height} This is the height of the cobordism (``height'' interpreted in its own internal coordinate system).
% With no offset (q.v.), this would be the distance between the centres of the first incoming and first outgoing boundary components.
% \item \DescribeMacro{tqft/boundary separation} This is the distance between the centres of the boundary components of the same type.
% \item \DescribeMacro{tqft/circle width} This is the half-width of the boundary circles.
% \item \DescribeMacro{tqft/circle depth} This is the half-depth of the boundary circles (``depth'' since, in the internal coordinate system, this corresponds to the \(z\)-axis out of the page).
% \item \DescribeMacro{tqft/incoming boundary components} The number of incoming boundary components (can be zero).
% \item \DescribeMacro{tqft/outgoing boundary components} The number of outgoing boundary components (can be zero).
% \item \DescribeMacro{tqft/offset} This offsets the first outgoing boundary component horizontally relative to the first incoming boundary component.
% It is a dimensionless number (not necessarily an integer) and is interpreted so that a value of \(1\) aligns the first outgoing boundary component with the second incoming boundary component.
% \end{itemize}
%
%
%
% \section{Styling}
%
% There are various options for styling the diagrams.
% To understand how they work, it is important to know the order in which a cobordism is drawn and how many pieces it decomposes in to.
% This is the following list, with the corresponding key:
%
% \begin{enumerate}
% \item The boundary circles are drawn.
%
% \Verb+tqft/boundary style+
%
% \item The lower edges of the boundary circles are redrawn.
%
% \Verb+tqft/boundary lower style+
%
% \item The cobordism itself is drawn.
%
% \item The non-boundary edge of the cobordism is redrawn.
%
% \Verb+tqft/cobordism style+
%
% \item The upper edges of the boundary circles are redrawn.
%
% \Verb+tqft/boundary upper style+
% \end{enumerate}
%
% The fact that there are so many is to allow different style to be applied to different pieces.
% The duplication is to allow certain composite pieces to be \emph{filled}.
% All of these items can be styled separately.
% The style given to the node itself is passed on to the third item in that list, the cobordism itself.
% The styles of the others are controlled by a series of keys, each of should be a list of style to be applied to that component.
% Not all options make sense, in particular only the first and third can be filled.
% (That is, the \Verb+fill+ style is ignored on the other components.)
%
% Here is a progressively built up cobordism.
%
% \begin{example}
% \begin{center}
% \begin{tikzpicture}
% \begin{scope}[tqft/boundary style={fill=purple,fill opacity=1}]
% \node[tqft/cylinder] at (1,0) {};
% \begin{scope}[tqft/boundary lower style={draw,dashed,green,thick}]
% \node[tqft/cylinder] at (2,0) {};
% \begin{scope}
% \node[tqft/cylinder,fill=yellow,fill opacity=.7] at (3,0) {};
% \begin{scope}[tqft/cobordism style={draw,thick,blue}]
% \node[tqft/cylinder,fill=yellow,fill opacity=.7] at (4,0) {};
% \begin{scope}[tqft/boundary upper style={draw,thick,orange}]
% \node[tqft/cylinder,fill=yellow,fill opacity=.7] at (5,0) {};
% \end{scope}
% \end{scope}
% \end{scope}
% \end{scope}
% \end{scope}
% \end{tikzpicture}
% \end{center}
% \end{example}
%
% \section{Anchors}
%
% As with all PGF node shapes, there are certain anchors defined by the \Verb+tqft+ shape.
% These are the \Verb+center+ (and \Verb+centre+) anchors and the \Verb+incoming boundary n+, \Verb+outgoing boundary n+ anchors.
% The positioning of the \Verb+center+ anchor is slightly unusual in that if there are no, say, incoming boundary components then the centre anchor is still at the same height above the outgoing boundary components as if there were incoming boundary components.
% The reason for this is two-fold: computing the \emph{actual} centre of the shape in such circumstances would be tricky, and when aligning these shapes it is more useful to have the anchors consistent across shapes of varying boundary components.
%
% The \Verb+incoming boundary n+ and \Verb+outgoing boundary n+ are placed at the centres of the corresponding boundary components, with the numbering starting at the left or the top as appropriate to the flow of the cobordism.
% As the number of components can vary from shape to shape, for simplicity a set number of anchors are defined.
% In addition to simplifying the code (since one has to declare the anchors before knowing the value of any of the keys), this helps line up shapes alongside each other.
% The number of anchors is set by a key \DescribeMacro{tqft/maxlabels} (default \pgfkeysvalueof{/pgf/tqft/maxlabels}).
% As this has to be set \emph{before} the shape is declared and this happens when the package is loaded, the way to change this is via a package option:
%
% \Verb+\usepackage[maxlabels=12]{tqft}+
%
% \section{Improvements}
%
% Here are some ideas for extending this, and some minor ``bugs''.
%
% \begin{enumerate}
% \item Figure out how to define a variable number of anchors so that the hack of defining ``enough'' incoming and outgoing anchors isn't needed.
% \item Add more anchors (such as \Verb+east+ and \Verb+west+).
% Make \Verb+incoming boundary+ an alias of \Verb+incoming boundary 1+ so that if there is only one incoming boundary component then we don't need to specify the number (ditto outgoing).
% \item No thought has been given as to where the text gets placed if it is specified.
% \item Add the ability to hide certain boundary components.
% This is useful if the shapes are not specified in their natural order so certain boundary components should be hidden behind earlier drawn shapes.
% \item Some style options on the main node get passed to the other pieces (\Verb+fill opacity+ being one).
% This shouldn't happen, or should happen by design not by accident.
% \item The bounding box isn't as good as it could be.
% \item Add a way to specify more directions for the flow.
% \item Add the ability to apply different styles to the incoming and outgoing components.
% \end{enumerate}
%
% \section{More Examples}
%
% \begin{example}
% \begin{center}
% \begin{tikzpicture}[tqft/cobordism height=1.5cm,tqft/boundary % separation=1.5cm]
% \foreach \coord/\style in {
%   {(0,0)}/{tqft/view from=outgoing,fill},
%   {(5,0)}/{tqft/view from=incoming,draw},
%   {(0,-8)}/{fill=orange,fill opacity=.5,tqft/boundary lower % style={draw,blue,ultra thin,dashed},tqft/boundary upper % style={draw,green},tqft/cobordism style={draw,purple},tqft/boundary % style={fill=yellow}},
%   {(5,-8)}/{fill=orange,fill opacity=.5,tqft/cobordism % style={draw,purple},tqft/boundary style={fill=yellow,draw=green}}%
% } {
% \begin{scope}
%   \edef\styleit{\noexpand\tikzset{every node/.style={\style}}}
%   \styleit
% \node[tqft/cap] (h) at \coord {};
% \node[tqft/pair of pants,anchor=incoming boundary 1] (a) at  (h.outgoing boundary 1) {};
% \node[tqft/cylinder to next,anchor=incoming boundary 1] (d) at  (a.incoming boundary 2) {};
% \node[tqft/reverse pair of pants,anchor=incoming boundary 1] (b) at % (a.outgoing boundary 2) {};
% \node[tqft/cylinder to prior,anchor=incoming boundary 1] (c) at  (b.outgoing boundary 1) {};
% \node[tqft/cylinder,anchor=incoming boundary 1] (e) at (a.outgoing  boundary 1) {};
% \node[tqft/cylinder,anchor=incoming boundary 1] (f) at (e.outgoing  boundary 1) {};
% \node[tqft/reverse pair of pants,anchor=incoming boundary 1] (g) at  (f.outgoing boundary 1) {};
% \node[tqft/cup,anchor=incoming boundary 1] (i) at (g.outgoing boundary 1) {};
% \end{scope}
% }
% \end{tikzpicture}
% \end{center}
% \end{example}
%
%
% \begin{example}
% \begin{center}
% \begin{tikzpicture}
% \node[draw,tqft/pair of pants] (a) {};
% \node[draw,tqft/cap,anchor=outgoing boundary 1] at (a.incoming boundary 1) {};
% \node[fill,tqft/cup,anchor=incoming boundary 1] at (a.outgoing boundary 1) {};
% \node[draw,tqft/cup,anchor=incoming boundary 1] at (a.outgoing boundary 2) {};
% \begin{scope}[tqft/flow=east]
% \node[draw,tqft/pair of pants] (a) at (4,0) {};
% \node[draw,tqft/cap,anchor=outgoing boundary 1] at (a.incoming boundary 1) {};
% \node[fill,tqft/cup,anchor=incoming boundary 1] at (a.outgoing boundary 1) {};
% \node[draw,tqft/cup,anchor=incoming boundary 1] at (a.outgoing boundary 2) {};
% \end{scope}
% \begin{scope}[tqft/flow=north]
% \node[draw,tqft/pair of pants] (a) at (0,-4) {};
% \node[draw,tqft/cap,anchor=outgoing boundary 1] at (a.incoming boundary 1) {};
% \node[fill,tqft/cup,anchor=incoming boundary 1] at (a.outgoing boundary 1) {};
% \node[draw,tqft/cup,anchor=incoming boundary 1] at (a.outgoing boundary 2) {};
% \end{scope}
% \begin{scope}[tqft/flow=west]
% \node[draw,tqft/pair of pants] (a) at (4,-4) {};
% \node[draw,tqft/cap,anchor=outgoing boundary 1] at (a.incoming boundary 1) {};
% \node[fill,tqft/cup,anchor=incoming boundary 1] at (a.outgoing boundary 1) {};
% \node[draw,tqft/cup,anchor=incoming boundary 1] at (a.outgoing boundary 2) {};
% \end{scope}
% \end{tikzpicture}
% \end{center}
% \end{example}
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
% Pass any options through to \Verb+pgfkeys+
%    \begin{macrocode}
\RequirePackage{pgfkeys}
\RequirePackage{pgf}
\RequirePackage{pgfopts}
\pgfkeys{/pgf/tqft/.cd,
  maxlabels/.initial=10,
  maximum boundary labels/.style={maxlabels=#1}
}
\ProcessPgfOptions{/pgf/tqft}
%    \end{macrocode}
%
% We can view the cobordisms from the \emph{input} or \emph{output} ends, the implementation of the choice is to draw an arc from 0 to 180 or from 0 to -180 so we just need to track minus signs.
% These macros are for that.
%    \begin{macrocode}
\def\pgf@tqft@minus{-}
\let\pgf@tqft@upper\@empty
\let\pgf@tqft@lower\pgf@tqft@minus
%    \end{macrocode}
%
% The direction of the flow sets up a transformation to be applied to
% the node shapes; this complicates the anchors a little as they look
% different from the inside and the outside.
% These macros are the default transformations.
%    \begin{macrocode}
\def\pgf@tqft@flow@south{}
\def\pgf@tqft@flow@north{\pgftransformxscale{-1}\pgftransformrotate{180}}
\def\pgf@tqft@flow@east{\pgftransformyscale{-1}\pgftransformrotate{90}}
\def\pgf@tqft@flow@west{\pgftransformrotate{270}}
%    \end{macrocode}
%
% Declare some dimension registers to hold the specifications of the cobordism.
%    \begin{macrocode}
\newdimen\tqft@xa
\newdimen\tqft@xb
\newdimen\tqft@c
\newdimen\tqft@ch
\newdimen\tqft@h
\newdimen\tqft@s
\newdimen\tqft@w
%    \end{macrocode}
% Now we set up all the keys that we'll need in the course of this shape
%    \begin{macrocode}
\pgfkeys{
  /pgf/tqft/.style={/tikz/shape=tqft},
  /tikz/tqft/.search also={/pgf},
  /pgf/tqft/.cd,
  incoming boundary components/.initial=5,
  outgoing boundary components/.initial=4,
  offset/.initial=0,
  cobordism height/.initial=2cm,
  boundary separation/.initial=2cm,
  circle width/.initial=10pt,
  circle depth/.initial=5pt,
  flow/.initial=south,
  view from/.is choice,
  view from/incoming/.code={%
    \let\pgf@tqft@upper\pgf@tqft@minus
    \let\pgf@tqft@lower\@empty
  },
  view from/outgoing/.code={%
  \let\pgf@tqft@lower\pgf@tqft@minus
    \let\pgf@tqft@upper\@empty
  },
  boundary lower style contents/.initial={},
  boundary lower style/.code={%
    \pgfkeys{/pgf/tqft/boundary lower style contents/.style={%
        /tikz/.cd,#1
      }
    }
  },
  boundary style contents/.initial={},
  boundary style/.code={%
    \pgfkeys{/pgf/tqft/boundary style contents/.style={%
        /tikz/.cd,#1
      }
    }
  },
  boundary upper style contents/.initial={},
  boundary upper style/.code={%
    \pgfkeys{/pgf/tqft/boundary upper style contents/.style={%
        /tikz/.cd,#1
      }
    }
  },
  cobordism style contents/.initial={},
  cobordism style/.code={%
    \pgfkeys{/pgf/tqft/cobordism style contents/.style={%
        /tikz/.cd,#1%
      }
    }
  },
  pair of pants/.style={
    tqft,
    tqft/incoming boundary components=1,
    tqft/outgoing boundary components=2,
    tqft/offset=-.5
  },
  reverse pair of pants/.style={
    tqft,
    tqft/incoming boundary components=2,
    tqft/outgoing boundary components=1,
    tqft/offset=.5
  },
  cylinder to prior/.style={
    tqft,
    tqft/incoming boundary components=1,
    tqft/outgoing boundary components=1,
    tqft/offset=-.5
  },
  cylinder to next/.style={
    tqft,
    tqft/incoming boundary components=1,
    tqft/outgoing boundary components=1,
    tqft/offset=.5
  },
  cylinder/.style={
    tqft,
    tqft/incoming boundary components=1,
    tqft/outgoing boundary components=1
  },
  cup/.style={
    tqft,
    tqft/incoming boundary components=1,
    tqft/outgoing boundary components=0
  },
  cap/.style={
    tqft,
    tqft/incoming boundary components=0,
    tqft/outgoing boundary components=1
  }
}
%    \end{macrocode}
%
% \begin{macro}{tqft shape}
% This is a generic cobordism shape
%    \begin{macrocode}
\pgfdeclareshape{tqft}{
%    \end{macrocode}
% Save our specifications: incoming and outgoing boundary components
%    \begin{macrocode}
  \savedmacro{\tqft@incoming}{\edef\tqft@incoming{\pgfkeysvalueof{/pgf/tqft/incoming boundary components}}}
  \savedmacro{\tqft@outgoing}{\edef\tqft@outgoing{\pgfkeysvalueof{/pgf/tqft/outgoing boundary components}}}
%    \end{macrocode}
% and the offset (in units of boundary components) between the leading incoming and outgoing components (regarded as a shift of the outgoing components relative to the incoming)
%    \begin{macrocode}
  \savedmacro{\tqft@offset}{\edef\tqft@offset{\pgfkeysvalueof{/pgf/tqft/offset}}}
%    \end{macrocode}
% Now we save our dimensions: height, separation, and the radii of the boundary circles
%    \begin{macrocode}
  \saveddimen{\tqft@height}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/cobordism height}}
  \saveddimen{\tqft@separation}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/boundary separation}}
  \saveddimen{\tqft@width}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/circle width}}
  \saveddimen{\tqft@depth}{\pgf@x=\pgfkeysvalueof{/pgf/tqft/circle depth}}
%    \end{macrocode}
%
% For the externally available anchors, we need to save a few things with the flow transformation in place.
%    \begin{macrocode}
   \savedanchor{\tqft@start@incoming}{%
%    \end{macrocode}
% Apply the transformation
%    \begin{macrocode}
    \pgf@relevantforpicturesizefalse
    \csname pgf@tqft@flow@\pgfkeysvalueof{/pgf/tqft/flow}\endcsname
%    \end{macrocode}
% Find our current origin under the transformation and save it
%    \begin{macrocode}
    \pgfpointorigin
    \pgf@xa=\pgf@x
    \pgf@ya=\pgf@y
    \pgfmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
    \pgfgetlastxy{\pgf@tqft@ox}{\pgf@tqft@oy}
%    \end{macrocode}
% position of incoming boundary in internal coordinates 
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@xa}{-(max(\pgfkeysvalueof{/pgf/tqft/incoming boundary components} - 1,\pgfkeysvalueof{/pgf/tqft/outgoing boundary components} - 1 + \pgfkeysvalueof{/pgf/tqft/offset}) + min(0,\pgfkeysvalueof{/pgf/tqft/offset}) + 2 )*\pgfkeysvalueof{/pgf/tqft/boundary separation}/2}
    \pgfmathsetlength{\tqft@h}{.5 * \pgfkeysvalueof{/pgf/tqft/cobordism height}}
    \pgfmoveto{\pgfpoint{\tqft@xa}{\tqft@h}}
    \pgfgetlastxy{\pgf@tqft@x}{\pgf@tqft@y}
%    \end{macrocode}
% absolute position
%    \begin{macrocode}
    \setlength{\pgf@x}{\pgf@tqft@x}
    \setlength{\pgf@y}{\pgf@tqft@y}
    \setlength{\pgf@xa}{\pgf@tqft@ox}
    \setlength{\pgf@ya}{\pgf@tqft@oy}
%    \end{macrocode}
% now relative to internal origin
%    \begin{macrocode}
    \advance\pgf@x by -\pgf@xa
    \advance\pgf@y by -\pgf@ya
}
%    \end{macrocode}
%    \begin{macrocode}
   \savedanchor{\tqft@start@outgoing}{%
%    \end{macrocode}
% Apply the transformation
%    \begin{macrocode}
    \pgf@relevantforpicturesizefalse
    \csname pgf@tqft@flow@\pgfkeysvalueof{/pgf/tqft/flow}\endcsname
%    \end{macrocode}
% Find our current origin under the transformation and save it
%    \begin{macrocode}
    \pgfpointorigin
    \pgf@xa=\pgf@x
    \pgf@ya=\pgf@y
    \pgfmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
    \pgfgetlastxy{\pgf@tqft@ox}{\pgf@tqft@oy}
%    \end{macrocode}
% position of incoming boundary in internal coordinates 
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@xa}{-(max(\pgfkeysvalueof{/pgf/tqft/incoming boundary components} - 1,\pgfkeysvalueof{/pgf/tqft/outgoing boundary components} - 1 + \pgfkeysvalueof{/pgf/tqft/offset}) + min(0,\pgfkeysvalueof{/pgf/tqft/offset}) + 2 - 2*\pgfkeysvalueof{/pgf/tqft/offset})*\pgfkeysvalueof{/pgf/tqft/boundary separation}/2}
    \pgfmathsetlength{\tqft@h}{-.5 * \pgfkeysvalueof{/pgf/tqft/cobordism height}}
    \pgfmoveto{\pgfpoint{\tqft@xa}{\tqft@h}}
    \pgfgetlastxy{\pgf@tqft@x}{\pgf@tqft@y}
%    \end{macrocode}
% absolute position
%    \begin{macrocode}
    \setlength{\pgf@x}{\pgf@tqft@x}
    \setlength{\pgf@y}{\pgf@tqft@y}
    \setlength{\pgf@xa}{\pgf@tqft@ox}
    \setlength{\pgf@ya}{\pgf@tqft@oy}
%    \end{macrocode}
% now relative to internal origin
%    \begin{macrocode}
    \advance\pgf@x by -\pgf@xa
    \advance\pgf@y by -\pgf@ya
}
%    \end{macrocode}
%    \begin{macrocode}
   \savedanchor{\tqft@direction}{%
%    \end{macrocode}
% Apply the transformation
%    \begin{macrocode}
    \csname pgf@tqft@flow@\pgfkeysvalueof{/pgf/tqft/flow}\endcsname
%    \end{macrocode}
% Find our current origin under the transformation and save it
%    \begin{macrocode}
    \pgfpointorigin
    \pgf@xa=\pgf@x
    \pgf@ya=\pgf@y
    \pgfmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
    \pgfgetlastxy{\pgf@tqft@ox}{\pgf@tqft@oy}
%    \end{macrocode}
% orientation of cobordism
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@xa}{\pgfkeysvalueof{/pgf/tqft/boundary separation}}
%    \pgfmathsetlength{\tqft@h}{\pgfkeysvalueof{/pgf/tqft/cobordism height}}
%    \pgfmoveto{\pgfpoint{\tqft@xa}{\tqft@h}}
    \pgfmoveto{\pgfpoint{\tqft@xa}{0pt}}
    \pgfgetlastxy{\pgf@tqft@x}{\pgf@tqft@y}
%    \end{macrocode}
% absolute position
%    \begin{macrocode}
    \setlength{\pgf@x}{\pgf@tqft@x}
    \setlength{\pgf@y}{\pgf@tqft@y}
    \setlength{\pgf@xa}{\pgf@tqft@ox}
    \setlength{\pgf@ya}{\pgf@tqft@oy}
%    \end{macrocode}
% now relative to internal origin
%    \begin{macrocode}
    \advance\pgf@x by -\pgf@xa
    \advance\pgf@y by -\pgf@ya
}
%    \end{macrocode}
% These are our externally available anchors
%    \begin{macrocode}
  \anchor{centre}{\pgfpointorigin}
  \anchor{center}{\pgfpointorigin}
{
  \foreach \tqft@k in {1,...,\pgfkeysvalueof{/pgf/tqft/maxlabels}} {
    \edef\tqft@anchor{\noexpand\anchor{incoming boundary \tqft@k}{
    \noexpand\tqft@start@incoming
    \noexpand\pgf@xa=\noexpand\pgf@x
    \noexpand\pgf@ya=\noexpand\pgf@y
    \noexpand\tqft@direction
    \noexpand\pgf@xb=\noexpand\pgf@x
    \noexpand\pgf@yb=\noexpand\pgf@y
    \noexpand\advance\noexpand\pgf@xa by \tqft@k\noexpand\pgf@xb
    \noexpand\advance\noexpand\pgf@ya by \tqft@k\noexpand\pgf@yb
    \noexpand\pgf@x=\noexpand\pgf@xa
    \noexpand\pgf@y=\noexpand\pgf@ya
    }}

    \tqft@anchor
}
  }
{
  \foreach \tqft@k in {1,...,\pgfkeysvalueof{/pgf/tqft/maxlabels}} {
    \edef\tqft@anchor{\noexpand\anchor{outgoing boundary \tqft@k}{
    \noexpand\tqft@start@outgoing
    \noexpand\pgf@xa=\noexpand\pgf@x
    \noexpand\pgf@ya=\noexpand\pgf@y
    \noexpand\tqft@direction
    \noexpand\pgf@xb=\noexpand\pgf@x
    \noexpand\pgf@yb=\noexpand\pgf@y
    \noexpand\advance\noexpand\pgf@xa by \tqft@k\noexpand\pgf@xb
    \noexpand\advance\noexpand\pgf@ya by \tqft@k\noexpand\pgf@yb
    \noexpand\pgf@x=\noexpand\pgf@xa
    \noexpand\pgf@y=\noexpand\pgf@ya
    }}

    \tqft@anchor
}
  }
%    \end{macrocode}
% Now we define the background path.
% This is the upper part of the cobordism.
%    \begin{macrocode}
  \backgroundpath{
%    \end{macrocode}
% Apply the internal transformation
%    \begin{macrocode}
    \csname pgf@tqft@flow@\pgfkeysvalueof{/pgf/tqft/flow}\endcsname
%    \end{macrocode}
% Convert the boundary separation and width to lengths
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@s}{\tqft@separation}
    \pgfmathsetlength{\tqft@w}{2*\tqft@width}
%    \end{macrocode}
% Compute the starting position of the incoming boundary components so that we get the centre anchor on the centre of the cobordism
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@xa}{-(max(\tqft@incoming - 1,\tqft@outgoing - 1 + \tqft@offset) + min(0,\tqft@offset))*\tqft@s/2 - \tqft@width}
    \tqft@xb=\tqft@xa
    \advance\tqft@xb by \tqft@w
    \pgfmathsetlength{\tqft@c}{.5 * \tqft@height - 4 * \tqft@depth}
    \pgfmathsetlength{\tqft@h}{.5 * \tqft@height}
%    \end{macrocode}
% Do we have any incoming boundary components at all?
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
%    \end{macrocode}
% Yes, so move to the position of the first and draw it
%    \begin{macrocode}
    \pgfpathmoveto{\pgfqpoint{\tqft@xa}{\tqft@h}}
     \pgfpatharc{\pgf@tqft@upper180}{0}{\tqft@width and \tqft@depth}
%    \end{macrocode}
% Do we have any more incoming boundary components?
%    \begin{macrocode}
   \ifnum\tqft@incoming>1
%    \end{macrocode}
% Yes, so iterate over the remaining incoming boundary components
%    \begin{macrocode}
    \foreach \tqft@k in {2,...,\tqft@incoming} {
     \advance\tqft@xa by \tqft@k\tqft@s
     \advance\tqft@xb by \tqft@k\tqft@s
     \advance\tqft@xb by -2\tqft@s
     \advance\tqft@xa by -\tqft@s
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@c}}{\pgfqpoint{\tqft@xa}{\tqft@c}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
     \pgfpatharc{\pgf@tqft@upper180}{0}{\tqft@width and \tqft@depth}
    }
    \fi
%    \end{macrocode}
% If we don't have any outgoing boundary components, may as well close up now.
%    \begin{macrocode}
    \ifnum\tqft@outgoing=0
     \advance\tqft@xb by \tqft@incoming\tqft@s
     \advance\tqft@xb by -\tqft@s
     \pgfmathsetlength{\tqft@ch}{max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
    \fi
    \fi
%    \end{macrocode}
% Shift down to the outgoing components, if we have any
%    \begin{macrocode}
    \ifnum\tqft@outgoing>0
     \advance\tqft@xb by \tqft@incoming\tqft@s
     \advance\tqft@xb by -\tqft@s
     \pgfmathsetlength{\tqft@xa}{\tqft@xa + (\tqft@outgoing - 1 + \tqft@offset) * \tqft@separation + 2*\tqft@width}
%    \end{macrocode}
% If we had incoming boundaries, this is a curveto, otherwise it's a moveto
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
     \pgfmathsetlength{\tqft@ch}{max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \else
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \fi
     \tqft@xb=\tqft@xa
     \advance\tqft@xb by -\tqft@w
%    \end{macrocode}
% Now draw the lower components
%    \begin{macrocode}
     \pgfpatharc{0}{\pgf@tqft@upper180}{\tqft@width and \tqft@depth}
%    \end{macrocode}
% Now iterate over the remaining outgoing boundary components
%    \begin{macrocode}
    \ifnum\tqft@outgoing>1
    \foreach \tqft@k in {2,...,\tqft@outgoing} {
     \advance\tqft@xa by -\tqft@k\tqft@s
     \advance\tqft@xb by -\tqft@k\tqft@s
     \advance\tqft@xb by 2\tqft@s
     \advance\tqft@xa by \tqft@s
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@c}}{\pgfqpoint{\tqft@xa}{-\tqft@c}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
     \pgfpatharc{0}{\pgf@tqft@upper180}{\tqft@width and \tqft@depth}
    }
    \fi
%    \end{macrocode}
% Shift back up to the incoming components, if we had any, otherwise arc back to our starting point
%    \begin{macrocode}
     \advance\tqft@xb by -\tqft@outgoing\tqft@s
     \advance\tqft@xb by \tqft@s
    \ifnum\tqft@incoming>0
     \pgfmathsetlength{\tqft@xa}{\tqft@xa - (\tqft@outgoing -1 + \tqft@offset) * \tqft@separation - 2*\tqft@width}
     \pgfmathsetlength{\tqft@ch}{max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
    \else
     \pgfmathsetlength{\tqft@ch}{max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \fi
    \fi
%    \end{macrocode}
% Close the path
%    \begin{macrocode}
     \pgfpathclose
  }
%    \end{macrocode}
% End of background path
% Now we define the behind background path.
% This is the lower part of the boundary circles.
%    \begin{macrocode}
  \behindbackgroundpath{
%    \end{macrocode}
% Apply the internal transformation
%    \begin{macrocode}
    \csname pgf@tqft@flow@\pgfkeysvalueof{/pgf/tqft/flow}\endcsname
%    \end{macrocode}
% Convert the boundary separation and width to lengths
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@s}{\tqft@separation}
    \pgfmathsetlength{\tqft@w}{2*\tqft@width}
%    \end{macrocode}
% Compute the starting position of the incoming boundary components so that we get the centre anchor on the centre of the cobordism
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@xa}{-(max(\tqft@incoming - 1,\tqft@outgoing - 1 + \tqft@offset) + min(0,\tqft@offset) + 2)*\tqft@separation/2}
    \pgfmathsetlength{\tqft@h}{.5 * \tqft@height}
%    \end{macrocode}
% This section draws the boundary circles
%    \begin{macrocode}
    {
%    \end{macrocode}
% Initialise the TikZ path settings and read in the style options for the boundary
%    \begin{macrocode}
      \tikz@mode@fillfalse%
      \tikz@mode@drawfalse%
      \let\tikz@mode=\pgfutil@empty
      \let\tikz@options=\pgfutil@empty
      \tikzset{tqft/boundary style contents}
      \tikz@mode
      \tikz@options
%    \end{macrocode}
% Do we have any incoming boundary components at all?
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
%    \end{macrocode}
% Yes, so iterate over them
%    \begin{macrocode}
    \foreach \tqft@k in {1,...,\tqft@incoming} {
     \advance\tqft@xa by \tqft@k\tqft@s
     \pgfpathellipse{\pgfqpoint{\tqft@xa}{\tqft@h}}{\pgfqpoint{\tqft@width}{0pt}}{\pgfqpoint{0pt}{\tqft@depth}}
    }
    \fi
%    \end{macrocode}
% Now iterate over the outgoing boundary components, if we have any
%    \begin{macrocode}
    \ifnum\tqft@outgoing>0
     \pgfmathsetlength{\tqft@xa}{\tqft@xa + (\tqft@outgoing + \tqft@offset + 1) * \tqft@separation}
    \foreach \tqft@k in {1,...,\tqft@outgoing} {
     \advance\tqft@xa by -\tqft@k\tqft@s
%     \advance\tqft@xa by \tqft@s
     \pgfpathellipse{\pgfqpoint{\tqft@xa}{-\tqft@h}}{\pgfqpoint{\tqft@width}{0pt}}{\pgfqpoint{0pt}{\tqft@depth}}
    }
    \fi
%    \end{macrocode}
%    \begin{macrocode}
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@fill fill,\fi%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
    }
%    \end{macrocode}
% This section draws the lower parts of the boundary circles
%    \begin{macrocode}
    {
%    \end{macrocode}
% Initialise the TikZ path settings and read in the style options for the boundary
%    \begin{macrocode}
      \tikz@mode@fillfalse%
      \tikz@mode@drawfalse%
      \let\tikz@mode=\pgfutil@empty
      \let\tikz@options=\pgfutil@empty
      \tikzset{tqft/boundary lower style contents}
      \tikz@mode
      \tikz@options
      \advance\tqft@xa by .5\tqft@w
%    \end{macrocode}
% Do we have any incoming boundary components at all?
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
%    \end{macrocode}
% Yes, so iterate over them
%    \begin{macrocode}
    \foreach \tqft@k in {1,...,\tqft@incoming} {
     \advance\tqft@xa by \tqft@k\tqft@s
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{\tqft@h}}
     \pgfpatharc{0}{\pgf@tqft@lower180}{\tqft@width and \tqft@depth}
    }
    \fi
%    \end{macrocode}
% Now iterate over the outgoing boundary components, if we have any
%    \begin{macrocode}
    \ifnum\tqft@outgoing>0
     \pgfmathsetlength{\tqft@xa}{\tqft@xa + (\tqft@outgoing + \tqft@offset + 1) * \tqft@separation}
    \foreach \tqft@k in {1,...,\tqft@outgoing} {
     \advance\tqft@xa by -\tqft@k\tqft@s
%     \advance\tqft@xa by \tqft@s
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{-\tqft@h}}
     \pgfpatharc{0}{\pgf@tqft@lower180}{\tqft@width and \tqft@depth}
    }
    \fi
%    \end{macrocode}
%    \begin{macrocode}
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@fill fill,\fi%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
    }
  }
%    \end{macrocode}
% End of behind background path.
%
% Now we define the before background path.
% This is the upper part of the boundary circles and the cobordism edge.
%    \begin{macrocode}
  \beforebackgroundpath{
%    \end{macrocode}
% We \emph{don't} apply the internal transformation as it is already in place from the \Verb+\backgroundpath+.
% Convert the boundary separation and width to lengths
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@s}{\tqft@separation}
    \pgfmathsetlength{\tqft@w}{2*\tqft@width}
%    \end{macrocode}
% Compute the starting position of the incoming boundary components so that we get the centre anchor on the centre of the cobordism
%    \begin{macrocode}
    \pgfmathsetlength{\tqft@xa}{-(max(\tqft@incoming - 1,\tqft@outgoing - 1 + \tqft@offset) + min(0,\tqft@offset))*\tqft@s/2 - \tqft@width}
    \tqft@xb=\tqft@xa
    \advance\tqft@xb by \tqft@w
    \pgfmathsetlength{\tqft@c}{.5 * \tqft@height - 4 * \tqft@depth}
    \pgfmathsetlength{\tqft@h}{.5 * \tqft@height}
%    \end{macrocode}
% This section draws the non-boundary part of the cobordism.
%    \begin{macrocode}
   {
%    \end{macrocode}
% Initialise the TikZ path settings and read in the style options for the boundary
%    \begin{macrocode}
      \tikz@mode@fillfalse%
      \tikz@mode@drawfalse%
      \let\tikz@mode=\pgfutil@empty
      \let\tikz@options=\pgfutil@empty
      \tikzset{tqft/cobordism style contents}
      \tikz@mode
      \tikz@options
% Do we have any incoming boundary components at all?
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
%    \end{macrocode}
% Do we have more than one?
%    \begin{macrocode}
   \ifnum\tqft@incoming>1
%    \end{macrocode}
% Yes, so iterate over the remaining incoming boundary components
%    \begin{macrocode}
    \foreach \tqft@k in {2,...,\tqft@incoming} {
     \advance\tqft@xa by \tqft@k\tqft@s
     \advance\tqft@xb by \tqft@k\tqft@s
     \advance\tqft@xb by -2\tqft@s
     \advance\tqft@xa by -\tqft@s
    \pgfpathmoveto{\pgfqpoint{\tqft@xb}{\tqft@h}}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@c}}{\pgfqpoint{\tqft@xa}{\tqft@c}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
    }
    \fi
%    \end{macrocode}
% If we don't have any outgoing boundary components, may as well close up now.
%    \begin{macrocode}
    \ifnum\tqft@outgoing=0
     \advance\tqft@xb by \tqft@incoming\tqft@s
     \advance\tqft@xb by -\tqft@s
     \pgfmathsetlength{\tqft@ch}{max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1))}
    \pgfpathmoveto{\pgfqpoint{\tqft@xb}{\tqft@h}}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
    \fi
    \fi
%    \end{macrocode}
% Shift down to the outgoing components, if we have any
%    \begin{macrocode}
    \ifnum\tqft@outgoing>0
     \advance\tqft@xb by \tqft@incoming\tqft@s
     \advance\tqft@xb by -\tqft@s
     \pgfmathsetlength{\tqft@xa}{\tqft@xa + (\tqft@outgoing - 1 + \tqft@offset) * \tqft@separation + 2*\tqft@width}
%    \end{macrocode}
% If we had incoming boundaries, this is a curveto, otherwise it's a moveto
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
     \pgfmathsetlength{\tqft@ch}{max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1))}
     \pgfpathmoveto{\pgfqpoint{\tqft@xb}{\tqft@h}}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \else
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \fi
     \tqft@xb=\tqft@xa
     \advance\tqft@xb by -\tqft@w
%    \end{macrocode}
% Now draw the lower components
%    \begin{macrocode}
     \pgfpathmoveto{\pgfqpoint{\tqft@xb}{-\tqft@h}}
%    \end{macrocode}
% Now iterate over the remaining outgoing boundary components
%    \begin{macrocode}
    \ifnum\tqft@outgoing>1
    \foreach \tqft@k in {2,...,\tqft@outgoing} {
     \advance\tqft@xa by -\tqft@k\tqft@s
     \advance\tqft@xb by -\tqft@k\tqft@s
     \advance\tqft@xb by 2\tqft@s
     \advance\tqft@xa by \tqft@s
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@c}}{\pgfqpoint{\tqft@xa}{-\tqft@c}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
     \advance\tqft@xa by -\tqft@w
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    }
    \fi
%    \end{macrocode}
% Shift back up to the incoming components, if we had any, otherwise arc back to our starting point
%    \begin{macrocode}
     \advance\tqft@xb by -\tqft@outgoing\tqft@s
     \advance\tqft@xb by \tqft@s
    \ifnum\tqft@incoming>0
     \pgfmathsetlength{\tqft@xa}{\tqft@xa - (\tqft@outgoing -1 + \tqft@offset) * \tqft@separation - 2*\tqft@width}
     \pgfmathsetlength{\tqft@ch}{max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@ch}}{\pgfqpoint{\tqft@xa}{\tqft@h}}
    \else
     \pgfmathsetlength{\tqft@ch}{max(-\tqft@h,\tqft@h - (\tqft@h - \tqft@c) * ((abs(\tqft@xb - \tqft@xa) - \tqft@w)/\tqft@s + 1))}
     \pgfpathcurveto{\pgfqpoint{\tqft@xb}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@ch}}{\pgfqpoint{\tqft@xa}{-\tqft@h}}
    \fi
    \fi
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@fill fill,\fi%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
}
%    \end{macrocode}
% This section draws the upper parts of the boundary circles
%    \begin{macrocode}
    {
%    \end{macrocode}
% Initialise the TikZ path settings and read in the style options for the boundary
%    \begin{macrocode}
      \tikz@mode@fillfalse%
      \tikz@mode@drawfalse%
      \let\tikz@mode=\pgfutil@empty
      \let\tikz@options=\pgfutil@empty
      \tikzset{tqft/boundary upper style contents}
      \tikz@mode
      \tikz@options
      \advance\tqft@xa by -\tqft@s
      \advance\tqft@xa by \tqft@w
%    \end{macrocode}
% Do we have any incoming boundary components at all?
%    \begin{macrocode}
    \ifnum\tqft@incoming>0
%    \end{macrocode}
% Yes, so iterate over them
%    \begin{macrocode}
    \foreach \tqft@k in {1,...,\tqft@incoming} {
     \advance\tqft@xa by \tqft@k\tqft@s
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{\tqft@h}}
     \pgfpatharc{0}{\pgf@tqft@upper180}{\tqft@width and \tqft@depth}
    }
    \fi
%    \end{macrocode}
% Now iterate over the outgoing boundary components, if we have any
%    \begin{macrocode}
    \ifnum\tqft@outgoing>0
     \pgfmathsetlength{\tqft@xa}{\tqft@xa + (\tqft@outgoing + \tqft@offset + 1) * \tqft@separation}
    \foreach \tqft@k in {1,...,\tqft@outgoing} {
     \advance\tqft@xa by -\tqft@k\tqft@s
%     \advance\tqft@xa by \tqft@s
     \pgfpathmoveto{\pgfqpoint{\tqft@xa}{-\tqft@h}}
     \pgfpatharc{0}{\pgf@tqft@upper180}{\tqft@width and \tqft@depth}
    }
    \fi
%    \end{macrocode}
%    \begin{macrocode}
      \edef\tikz@temp{\noexpand\pgfusepath{%
          \iftikz@mode@fill fill,\fi%
          \iftikz@mode@draw draw\fi%
      }}%
      \tikz@temp
    }
  }
}
%    \end{macrocode}
% \end{macro}
% \iffalse
%</package>
% \fi
%
% \Finale

\endinput
